<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2050热身赛（赶火车）【数学期望】]]></title>
    <url>%2F2019%2F04%2F11%2F2050%E7%83%AD%E8%BA%AB%E8%B5%9B%EF%BC%88%E8%B5%B6%E7%81%AB%E8%BD%A6%EF%BC%89%E3%80%90%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%E3%80%91%2F</url>
    <content type="text"><![CDATA[思路期望就是走这条路的概率*这条路到达的时间，设期望为Ex，则Ex=(a1+a2+…+an+(b1+Ex)+(b2+Ex)+…+(bm+Ex))/(n+m)，化简一下就是Ex=(a1+a2+…+an+b1+b2+…+bm)/n.式子的意思为，如果走可以到达终点的n条路的话，选取的概率就是1/(n+m)，所花时间就是ai，如果走其他的m条路的话，选取的概率是1/(n+m),所花时间就是bi+Ex.期望值一个近似平均值，当我们走那m条路时，走了bi时间后又回到原点，这时候跟最开始的情况又一样了，而我们已经设期望时间是Ex了，所以总共时间就是bi+Ex（自己好好思索一下） 代码123456789101112131415161718192021222324252627282930313233//// Created by yunqi on 19-4-11.//#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int main(void) &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, m; double y; scanf("%d%d%lf", &amp;n, &amp;m, &amp;y); double a, sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lf", &amp;a); sum += a; &#125; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%lf", &amp;a); sum += a; &#125; double ans = sum / n; if (ans &gt; y) printf("Wait\n"); else printf("Go\n"); &#125; return 0;&#125; 做题感受啊……看到这道题我就知道寒假训练时有一道题和这道很像，而我又忘记是怎么做的了（囧），所以又去翻代码，发现还不是很懂又直接去搜了题解orz啊……这次写了题解自己大概有一点认识吧（底气不足]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-特立独行的幸福数（2019年决赛）]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E5%B9%B8%E7%A6%8F%E6%95%B0%EF%BC%882019%E5%B9%B4%E5%86%B3%E8%B5%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思路幸福数求法是如果不是幸福数，那么一定会出现循环，一种方法是标记每次得到的数，另一种骚操作是判断20是否会出现（如果出现20，那么这个数就一定不是幸福数（小明某一次打表找到的规律而这道题还要判断是不是独立的，那么开个vector记录每次得到的数的前一个数，同时也记录每个幸福数要得到1需要经过几次转换，最后再判断是不是质数即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//// Created by yunqi on 19-4-5.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e4 + 10;int relate_num[maxn];vector&lt;int&gt; pre_num[maxn];vector&lt;int&gt; num;int prime[maxn];bool vis[maxn];int cnt = 0;void get_prime() &#123; for (int i = 2; i &lt;= maxn; i++) &#123; if (!vis[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;bool judge(int n) &#123; int nn = n; int ret = 0; while (true) &#123; int com = nn; while (nn != 0) &#123; ret += (nn % 10) * (nn % 10); nn /= 10; &#125; relate_num[n]++; if (ret == 1) return true; else if (ret == 4 || ret == 20 || ret == 16) return false; pre_num[ret].push_back(com); nn = ret; ret = 0; &#125;&#125;void init() &#123; for (int i = 1; i &lt;= maxn; i++) if (judge(i)) num.push_back(i);&#125;int main() &#123; int a, b; get_prime(); init(); while (~scanf("%d%d", &amp;a, &amp;b)) &#123; int _size = (int) num.size(); bool flag1=false; for (int i = 0; i &lt; _size; i++) &#123; if (num[i] &gt; b) break; if (num[i] &gt;= a &amp;&amp; num[i] &lt;= b) &#123; bool flag = true; for (int j = 0; j &lt; pre_num[num[i]].size() &amp;&amp; flag; j++) if (pre_num[num[i]][j] &gt;= a &amp;&amp; pre_num[num[i]][j] &lt;= b) flag = false; if (flag) &#123; printf("%d %d\n", num[i], relate_num[num[i]] * (vis[num[i]] ? 1 : 2)); flag1 = true; &#125; &#125; &#125; if(!flag1) printf("SAD\n"); &#125; return 0;&#125; 做题感受比赛的时候，啊……一直在卡，赛后发现自己题意理解错了，同时自己赛后补题的过程中发现你需要把这个数a的所有前一个数bi都判断一下是否在区间内，其实整体写下来也不难，哎自己太菜了]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-深入虎穴（2019年决赛）]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4%EF%BC%882019%E5%B9%B4%E5%86%B3%E8%B5%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思路这是一棵树，但要把无根变为有根，题目中“只有一个出口”的条件便能确定这个树的根，由根去dfs就行了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by yunqi on 19-4-3.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5 + 10;vector&lt;int&gt; num[maxn];bool judge[maxn];int maxdep, maxid;void dfs(int pos, int depth) &#123; if (num[pos].empty()) &#123; if (maxdep &lt; depth) &#123; maxdep = depth; maxid = pos; &#125; return; &#125; else &#123; for(int i = 0; i &lt; num[pos].size(); i++) dfs(num[pos][i],depth+1); return; &#125;&#125;int main(void) &#123; int n; while (~scanf("%d", &amp;n)) &#123; int k, a; memset(judge, false, sizeof(judge)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;k); for (int j = 1; j &lt;= k; j++) &#123; scanf("%d", &amp;a); num[i].push_back(a); judge[a] = true; &#125; &#125; maxdep = 0; for (int i = 1; i &lt;= n; i++) if (!judge[i]) dfs(i, 1); printf("%d\n",maxid); &#125; return 0;&#125; 做题感受啊啊比赛的时候没有仔细去看只有一个入口这个条件，想当然以为有多个入口，所以用了最暴力的dfs去做（当然超时了，最后只拿了19分，哎关于dfs树这种题其实在之前就已经做过好几道了，比如小字辈、愿天下有情人都是兄妹哎，这一次打得真的差]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-分而冶之]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%88%86%E8%80%8C%E5%86%B6%E4%B9%8B%2F</url>
    <content type="text"><![CDATA[思路这道题也不难，不用想到什么无向图连通判断，只要对攻下的城市做记录，在跑一遍所有的边，看是否有一条边两个点都没被记录，这样的边就是孤立边给的时间是600ms，k是100,m是10000，复杂度就是km，完全不会超时（要学会对复杂度的预判呐 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e4+10;struct Edge&#123; int u,v;&#125;edge[maxn];bool mark[maxn];int main(void)&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;edge[i].u,&amp;edge[i].v); int k,num,node; scanf("%d",&amp;k); while(k--)&#123; bool flag=true; memset(mark,false,sizeof(mark)); scanf("%d",&amp;num); for(int i=1;i&lt;=num;i++) &#123; scanf("%d", &amp;node); mark[node] = true; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!mark[edge[i].u]&amp;&amp;!mark[edge[i].v])&#123; flag=false; break; &#125; &#125; if(!flag) printf("NO\n"); else printf("YES\n"); &#125; &#125; return 0;&#125; 做题感受想复杂了，以为是无向图连通判断，发现自己不熟，就放弃这道题了]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-红色警报]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[思路第一种方法就是暴力，图我发现自己惯用vector来存，其实邻接矩阵也行，然后习惯用广搜，不习惯用深搜。比赛的时候想的巨复杂，其实还是因为自己做题太少，我居然想到用判断每个点所在连通块是否不连通来做（这也是我为什么想不到好的算法的原因吧，做题少脑子又木。用广搜算出连通块数量即可，也是很暴力的那种（似乎我现在对于暴力做很害怕？，注意的是攻占城市是一个一个攻占，已经被攻占的城市不涉及其他城市连通性，所以每次的基准连通量数目都要改（我没有想到这一点，所以才疯狂wa吧。用并查集来做也可以，不过也是偏向暴力的那种，每一次判断都要重新做一次并查集，基准连通数目每一次也要变，并查集通过计算根节点的数目得到连通块数目。注意的是连通块数目增１和不变都是不改变连通性的（被攻占的城市已经算一个连通块了 代码给出两种，一种深搜暴力，一种并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000;vector&lt;int&gt; G[maxn];int n,m,k,node[maxn];int arr[maxn][maxn];bool vis[maxn];queue&lt;int&gt; q;void bfs()&#123; while(!q.empty())&#123; int p=q.front(); q.pop(); vis[p]=true; for(int i=0;i&lt;G[p].size();i++)&#123; if(!vis[G[p][i]])&#123; q.push(G[p][i]); vis[G[p][i]]=true; &#125; &#125; &#125;&#125;int main(void)&#123; scanf("%d%d",&amp;n,&amp;m); int a,b,cnt=0; memset(arr,0,sizeof(arr)); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;a,&amp;b); if(!arr[a][b]&amp;&amp;!arr[b][a]) &#123; G[a].push_back(b); G[b].push_back(a); &#125; arr[a][b]=1; arr[b][a]=1; &#125; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;n;i++)&#123; if(!vis[i])&#123; cnt++; q.push(i); bfs(); &#125; &#125; scanf("%d",&amp;k); for(int j=1;j&lt;=k;j++)&#123; memset(vis,false,sizeof(vis)); for(int l=1;l&lt;=j-1;l++) vis[node[l]]=true; scanf("%d",&amp;node[j]); vis[node[j]]=true; int com=0; for(int i=0;i&lt;n;i++)&#123; if(!vis[i])&#123; com++; q.push(i); bfs(); &#125; &#125; if(com&gt;cnt) printf("Red Alert: City %d is lost!\n",node[j]); else printf("City %d is lost.\n",node[j]); if(j==n) printf("Game Over.\n"); cnt=com; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1000;int far[maxn];int n,m,k;bool vis[maxn];struct Edge&#123; int x,y;&#125;edge[maxn*5+10];void init()&#123; for(int i=0;i&lt;n;i++)&#123; vis[i]=false; far[i]=i; &#125;&#125;int find(int x)&#123; if(far[x]==x) return far[x]; else return far[x]=find(far[x]);&#125;void Union(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) far[x]=y;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;edge[i].x,&amp;edge[i].y); Union(edge[i].x,edge[i].y); &#125; int cnt=0,com,node; for(int i=0;i&lt;n;i++) if(far[i]==i) cnt++; scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++)&#123; com=0; scanf("%d",&amp;node); vis[node]=true; for(int j=0;j&lt;n;j++) far[j]=j; for(int j=1;j&lt;=m;j++) if(!vis[edge[j].x]&amp;&amp;!vis[edge[j].y]) Union(edge[j].x,edge[j].y); for(int j=0;j&lt;n;j++) if(far[j]==j) com++; if(com&gt;cnt+1) printf("Red Alert: City %d is lost!\n",node); else printf("City %d is lost.\n",node); if(i==n) printf("Game Over.\n"); cnt=com; &#125; &#125; return 0;&#125; 做题感受训练时真的心态崩了啊，一直在卡这道题，结束前只过了一个样例，后来又发现自己写蠢了一个地方，最后半个小时自己完全就是木的吧（你看这心态就不好打完吃饭的时候搜题解，才发现题意也理解错了，想的方法也巨他妈复杂。]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-猜数字]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%8C%9C%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[思路猜数字：其实非常简单，但是就是不知道为啥我没做对，这一次是用的map，比赛用的是结构体，真是绝了。map的lower_bound方法是找出第一个大于等于key的迭代器指针 代码12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;map&lt;int,string&gt; name;int main(void)&#123; int n; while(~scanf("%d",&amp;n))&#123; int num,ans; string s; double sum=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s&gt;&gt;num; name[num]=s; sum+=num; &#125; sum/=(2*n); map&lt;int,string&gt;::iterator it,it1; it=name.lower_bound((int)sum); it1=it; ans=it-&gt;first; if(sum-it-&gt;first&gt;(it1++)-&gt;first-sum) ans=(it++)-&gt;first; cout&lt;&lt;(int)sum&lt;&lt;" "&lt;&lt;name[ans]&lt;&lt;endl; &#125; return 0;&#125; 做题感受感觉很谜，为啥比赛时没过，我只是把结构体换成map而已。pintia只能看到两页的提交记录，也试验不了了，如果又是和小字辈一样的话，我真是要吐血orx]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-是否完全二叉搜索树]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思路二叉树的判断，如果是完全，则深度为h的树，除了第h层，其它层都是满的，这里用结构体来存二叉树，同时判断是否为完全。二叉树的空间定义为1&lt;&lt;20，其实用到的最大空间为1&lt;&lt;20-1，父节点为i，子节点就为i&lt;&lt;1,i&lt;&lt;1+1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define INF 0x3f3f3f3fusing namespace std;const int maxn=1&lt;&lt;20+1;int node[maxn],a;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=maxn;i++) node[i]=INF; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a); for(int j=1;j&lt;=maxn;)&#123; if(node[j]==INF)&#123; node[j]=a; break; &#125;else&#123; if(node[j]&lt;a) j&lt;&lt;=1; else j&lt;&lt;=1,j+=1; &#125; &#125; &#125; bool flag=true; int cnt=0; for(int i=1;i&lt;=maxn;i++)&#123; if(node[i]==INF) flag=false; if(node[i]!=INF)&#123; cnt++; printf("%d%c",node[i],cnt==n?'\n':' '); if(cnt==n) break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 做题感受比赛没有看这道题，在纠结前面的红色警报，但是才发现自己对二叉树的理解很差劲，就算看了也不一定会吧（所以说自己很差劲,勉励吧:(]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-愿天下有情人都是兄妹]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E6%84%BF%E5%A4%A9%E4%B8%8B%E6%9C%89%E6%83%85%E4%BA%BA%E9%83%BD%E6%98%AF%E5%85%84%E5%A6%B9%2F</url>
    <content type="text"><![CDATA[思路就是深搜（也是最直接的思路）,结构体存每个人的性别，父母id，如果父母id是-1，就记为0（没有人的id是00000），先搜第一个人的祖先，最多搜到第五代就停止，将搜到的id做标记，然后搜第二个人的祖先，如果在第五代之内有第一个人的祖先，那么就输出no这道题和小字辈很相似，都是深搜的题。我遇到了两个坑点，一个是每个人的父母也要标明性别，另一个是输入id，性别的时候，如果是用cin连续输入的话，有三个样例点就过不了，如果第一个id和性别分开输入的话，就可以过了（搜了很多关于cin的资料，但还是不明白，留给以后的自己填坑。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;const int maxn=int(1e5+10);struct Node&#123; char gender; int far; int mom;&#125;node[maxn];bool vis[maxn];bool ans;void dfs(int x,int ok,int depth)&#123; if(depth&gt;5||!ans||x==0) return ; if(ok==1&amp;&amp;vis[x])&#123; ans=false; return ; &#125; vis[x]=true; dfs(node[x].far,ok,depth+1); dfs(node[x].mom,ok,depth+1);&#125;int main()&#123; int n; while(cin&gt;&gt;n)&#123; int id,fid,mid; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;id; cin&gt;&gt;node[id].gender&gt;&gt;fid&gt;&gt;mid; fid=fid==-1?0:fid; mid=mid==-1?0:mid; node[id].far=fid; node[id].mom=mid; node[fid].gender='M'; node[mid].gender='F'; &#125; int k,a,b; cin&gt;&gt;k; while(k--)&#123; memset(vis,false,sizeof(vis)); ans=true; cin&gt;&gt;a&gt;&gt;b; if(node[a].gender==node[b].gender) printf("Never Mind\n"); else&#123; dfs(a,0,1); dfs(b,1,1); if(ans) printf("Yes\n"); else printf("No\n"); &#125; &#125; &#125; return 0;&#125; 做题感受比赛时纠结红色警报那道题了，这道题根本没看，不过私底下补题的时候还是遇到了坑点，估计比赛时做也没办法拿满分吧（还需努力啊。还有，一开始以为编号必须用字符串存，后来试了一下直接当int输入也可以。]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-小字辈]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%B0%8F%E5%AD%97%E8%BE%88%2F</url>
    <content type="text"><![CDATA[思路一道深搜题，不过要注意记忆化搜索，用maxx记录最小的那一辈(rank值最大），然后用vector存每一辈的下标，因为是顺序存的，所以输出也是递增的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=1e5+10;int _rank[maxn];int far[maxn];int getrank(int i)&#123; if(_rank[i]!=0) return _rank[i]; else return _rank[i]=getrank(far[i])+1;&#125;int main(void)&#123; int n; while(~scanf("%d",&amp;n))&#123; vector&lt;int&gt; ans[maxn]; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;far[i]); if(far[i]==-1) _rank[i]=1; else _rank[i]=0; &#125; int maxx=-1; for(int i=1;i&lt;=n;i++)&#123; getrank(i); maxx=max(maxx,_rank[i]); ans[_rank[i]].push_back(i); &#125; unsigned long _size=ans[maxx].size(); printf("%d\n",maxx); for(unsigned long i=0;i&lt;_size;i++) printf("%d%c",ans[maxx][i],i==_size-1?'\n':' '); &#125; return 0;&#125; 做题感受一开始我是没有用上面的代码实现深搜，就是dfs记录了搜索深度，每搜一次深度加1，现在想想并不是很好，很容易超时。上面的代码开了rank数组来记录，只要rank的值已经求出来了就立刻返回，记忆化搜索很妙啊:)然后关于按顺序输出，我也是东想西想，甚至还想开个map……(我在想什么……，不用上面代码vector实现，开个结构体排序处理一下也好嘛……(我x*&amp;.#$@….哦还不止如此，我调了很久最后发现不用多组输入就过，用就会wa一个样例点，但是我很认真的检查了关于初始化没有问题啊，当时真的是……绝了，然而我刚刚又交了之前貌似没过的代码，结果就过了，我:??????我一定是见到了异世界（或者我见到了平行世界的我见到的场景？？？（我在说什么……更新刚刚实时测试了一下，把有一个样例点没过的代码复制粘贴再提交了一次，发现就过了……什么神奇的网站xxxxxxxx（真的是要吐血，浪费我很多很多很多很多很多时间去纠结一个实际上没有错的东西？？？？？？体验真是极差cao]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－名人堂与代金劵]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%90%8D%E4%BA%BA%E5%A0%82%E4%B8%8E%E4%BB%A3%E9%87%91%E5%8A%B5%2F</url>
    <content type="text"><![CDATA[思路很简单很入门级的题，ACMer选手写这种题就是过家家，但是不知道最近我的脑袋是怎么了，这种题都会卡（卡nm?，这个脑子啊……，写个结构体然后排序不就好了嘛，充其量就是这个排名卡一下……哎，我居然在处理排名的时候又建了个数组然后非要用lower_bound来找分数一样的人有多少个然后在输出==，感觉我是被lower_boung带入歧途其实很简单的，用个com记录上一个排名，然后和当前的比较，如果分数一样，com不变，否则就更新为i，最后要注意当com&gt;k的时候才结束，不是输出k个就结束 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;const int maxn=1e4+10;struct Node&#123; string id; int score;&#125;stu[maxn];bool cmp(const Node&amp; a,const Node&amp; b)&#123; if(a.score&gt;b.score) return true; else if(a.score==b.score) return a.id&lt;b.id; else return false;&#125;int main(void)&#123; int n,g,k; while(~scanf("%d%d%d",&amp;n,&amp;g,&amp;k))&#123; int sum=0; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; stu[i].id &gt;&gt; stu[i].score; if (stu[i].score &gt;= g) sum += 50; else if (stu[i].score &gt;= 60 &amp;&amp; stu[i].score &lt; g) sum += 20; &#125; sort(stu+1,stu+n+1,cmp); int com=1; printf("%d\n",sum); for(int i=1;com&lt;=k;)&#123; cout&lt;&lt;com&lt;&lt;" "&lt;&lt;stu[i].id&lt;&lt;" "&lt;&lt;stu[i].score&lt;&lt;endl; if(stu[++i].score!=stu[com].score) com=i; &#125; &#125; return 0;&#125; 做题感受没啥感受，就是愈发觉得自己变蠢了]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－列车调度]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[思路这道题就是求递减子列的个数，我的方法是开一个数组来记录当前每个递减子列的尾值，如果要插入的这个数大于所有尾值中最大的那一个，那么ans就+1，这个数就是新的递减子列的头(同时也是这个递减子列的尾，因为此时子列只有它一个元素)，反之，用lower_bound找到最小的大于这个数的尾值，这个数就变为该递减子列的尾(更新尾值)。因为尾值数组始终保持递增(有序),所以可以用lower_bound来找。 代码12345678910111213141516171819202122232425262728#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e5+10;int a,b[maxn];int main(void)&#123; int n; while(cin&gt;&gt;n)&#123; int maxx=0,cnt=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a); if(a&gt;maxx)&#123; maxx=a; b[++cnt]=a; &#125;else&#123; unsigned long k=lower_bound(b+1,b+cnt+1,a)-b; b[k]=a; if(k==cnt) maxx=a; &#125; &#125; printf("%d\n",cnt); &#125; return 0;&#125; 做题感受比赛时没有拿满分，有一个样例点没过，是因为我把数字插入顺序想反了，虽然也能做，但是也更复杂，后来补题的时候忘了如果数组中没有找到大于特定值的时候lower_bound会返回什么，所以自己用了maxx来记录最大的尾值，然后之后又忘记如果k=cnt的话时maxx也要更新==，逻辑真是硬伤啊orz（就是上面的代码。如果要按照思路来写的话，删掉maxx,如果k=cnt+1的话，那么就b[++cnt]=a]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－关于堆的判断]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[思路堆(Heap)的概念清楚了这道题就不难，按照插入顺序建堆理解起来也不难，用map判断比较快。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;const int maxn=1010;map&lt;int,int&gt; num;int a[maxn];string str;int x,y;void print(bool ans)&#123; if(ans) cout&lt;&lt;"T"&lt;&lt;endl; else cout&lt;&lt;"F"&lt;&lt;endl;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); int j=i; while(j!=1)&#123; if(a[j]&lt;a[j/2]) swap(a[j],a[j/2]); j/=2; &#125; &#125; num.clear(); for(int i=1;i&lt;=n;i++) num[a[i]]=i; while(m--)&#123; bool ans=true; cin&gt;&gt;x; cin&gt;&gt;str; if(str=="and")&#123; cin&gt;&gt;y&gt;&gt;str&gt;&gt;str; if(num[x]/2!=num[y]/2) ans=false; print(ans); continue; &#125; cin&gt;&gt;str; if(str=="a")&#123; cin&gt;&gt;str&gt;&gt;str&gt;&gt;y; if(num[x]/2!=num[y]) ans=false; print(ans); continue; &#125; cin&gt;&gt;str; if(str=="root")&#123; if(num[x]!=1) ans=false; print(ans); continue; &#125; cin&gt;&gt;str&gt;&gt;y; if(num[y]/2!=num[x]) ans=false; print(ans); &#125; &#125; return 0;&#125; 做题感受咳咳，基础知识不牢固啊，堆的概念不清楚，并且一开始只想到先输入一行字符串，然后遍历判断是哪种情况，同时获取x和y的值，后来看到一篇博客分隔输入判断，实在是妙啊。不过这种方法的坑点是，无论你是否已经判断为哪种情况，你都需要把剩下的字符串全部输入完(否则输入缓存区还留有未处理的字符串，对下一次的输入造成影响)]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－倒数第N个字符串]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路脑子头脑风暴一下，或者手推，就会发现这道题可以转换为26进制来做（0为a,25为z），倒数第１个字符串是zzz，即zzz-aaa，倒数第二个字符串是zzy，即zzz-aab，倒数第26个字符串是zza，即zzz-aaz,即把n-1转换为26进制，然后用zzz相减即可 代码123456789101112131415161718192021222324252627#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int ans[10];int main(void) &#123; int l, n; while(~scanf("%d%d",&amp;l,&amp;n))&#123; int com[10], tnt = 0; n--; while (n != 0) &#123; com[++tnt] = n % 26; n /= 26; &#125; for (int i = 1; i &lt;= l; i++) ans[i] = 122; for (int i = l - tnt + 1, j = tnt; j &gt;= 1; i++, j--) ans[i] = 122 - com[j] ; for (int i = 1; i &lt;= l; i++) printf("%c", ans[i]); printf("\n"); &#125; return 0;&#125; 做题感受比赛时真的想了好久，哎，脑子是木的，有抓住一点26进制的影子（其实单纯的想到字母的相差关系也行），先开始一直对n取余、相除，后来想到n-1，然后才过的。归根结底还是思路和逻辑不够，解决办法刷题呗。]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马大定理＆＆费马小定理]]></title>
    <url>%2F2019%2F03%2F09%2F%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%EF%BC%86%EF%BC%86%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数＆欧拉定理＆欧拉降幂]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%86%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%EF%BC%86%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%2F</url>
    <content type="text"><![CDATA[前言上一篇博客我们讲到了快速幂(一般&amp;&amp;矩阵)，现在我们要讲讲一个叫欧拉降幂的东西，为了得到欧拉降幂公式，我们需要回顾一下欧拉函数，再到欧拉定理以及拓展欧拉定理。 欧拉函数公式欧拉函数phi[x],表示[1,x-1]区间中与x互质的数的个数phi[x]=x(1-1/a1)(1-1/a2)…(1-1/an)，其中ai是x的质因数那么就可以得到欧拉函数的一个性质，若p是质数，那么phi[p]=p-1(这一条有时会用到)以及phi[ip]=pphii，phi[ip]=(p-1)*phii 怎么求我们可以用线性筛筛出所有的欧拉函数，首先用线性筛找出[1,n]之间所有的素数，然后根据公式算出欧拉函数值下面是线性筛代码 12345678910111213141516const int maxn = 1e5;int prime[maxn];bool vis[maxn];int tot = 0;void get_prime() &#123; for (int i = 2; i &lt;= maxn; i++) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; i * prime[j] &lt;= maxn &amp;&amp; j &lt;= tot; j++) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 然后是求phi[x]的部分12345678910111213int get_phi(int n) &#123; //求n的欧拉函数值，即phi[n] int ret = n; for (int i = 1; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= n; i++) &#123; if (n % prime[i] == 0) &#123; ret *= (1 - 1 / prime[i]); while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret *= (1 - 1 / n); return ret;&#125; 欧拉定理有了欧拉函数做坚实的后盾，讲欧拉定理就不需要扯那些乱七八糟的东西了(好吧其实是我不会证“整那些干啥，会用就行了。”————鲁迅先扔一个公式，当a,n互质时，a^(phi[n])%n=1，这个公式可以推出a^(phi[n])与n互质(不是废话…似乎不是很直观的样子，那么再换一个a^b(mod n)=a^(b%phi[n])(mod n)(这大概是最有用的公式证明也比较简单，把b表示为phi[n]的一次多项式，即b=x*phi[n]+y，因为有a^(phi[n])%n=1,所以a^b(mod n)=a^y(mod n)=a^(b%phi[n])(mod n)ps:这个公式可以用于欧拉降幂（后面会将 拓展欧拉定理接下来咱们再整个拓展欧拉定理，嗯，拓展大多数情况下不都是从特殊情况推广到一般情况嘛，那咱再整个a,n不互质时有什么样的公式当b&lt;phi[n]时，a^b(mod n)=a^b(mod n);当b&gt;=phi[n]时，a^b(mod n)=a^(b%phi[n]+phi[n])(mod n)证明？不存在的，我还要头发呢！“整那些干啥，会用就行了。” ————鲁迅 欧拉降幂很庆幸，你不用再新推什么奇怪的公式，其实欧拉降幂公式就是欧拉定理和拓展欧拉定理结合起来关于欧拉降幂的应用场景，对于一个问题求a^b(mod n)根据条件把式子转换为三个中的一个好yeah降幂成功惹代码也不给了因为比较简单（不就是求欧拉函数再结合一下快速幂嘛 友情连接：欧拉函数&amp;欧拉定理&amp;降幂 总结(这个网站的mathjax支持好好啊，next自带的辣鸡]]></content>
      <categories>
        <category>算法</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂（一般＆＆矩阵）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%88%E4%B8%80%E8%88%AC%EF%BC%86%EF%BC%86%E7%9F%A9%E9%98%B5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言其实整个系列弄下来是因为尝试做了小米OJ的二月月赛，结果被狠狠压在地上打(哭，看了评论有人给出的题解，有道题因为涉及到矩阵快速幂，所以干脆把快速幂重新再看一遍。 原理一般朴素的幂积算法计算$a^b$时间复杂度是O(n)，而快速幂可以降到O(logn)，实现的原理是将b二进制化，$b=2^a_{1}+2^a_{2}+…+2^a_{k}$ , $a^b=a^｛2^a_{1}｝a^｛2^a_{2}｝…a^｛2^a_{k}｝$。这些a_{i}就是b的二进制为１的位数(末位取０，从低到高依次增1)，下面是具体实现代码 12345678910long long qpow(long long a, long long b) &#123; long long ret = 1; while (b != 0) &#123; if (b &amp; 1) ret *= a; a *= a; //累乘，以便随时对ret做出贡献 b &gt;&gt;= 1; &#125; return ret;&#125; 代码中我们用到了两种位运算 &amp; 和 &gt;&gt;，&amp;运算用于二进制取位操作，例如b&amp;1就是取二进制的末位，b&amp;1==1?b为奇数:b为偶数；&gt;&gt;运算去掉二进制的最后一位，b&gt;&gt;=1相当于b/2（向下取整） 矩阵快速幂矩阵快速幂是建立在快速幂之上的，只不过将a换成了一个矩阵，所以对于矩阵的相乘我们需要单独写一个函数来实现，以下是代码 1234567891011121314151617181920212223int temp[maxn][maxn]; inline void multi(int a[][maxn],int b[][maxn],int n)&#123; memset(temp,0,sizeof(temp)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) temp[i][j]+=a[i][k]*b[k][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=temp[i][j]; &#125; int ret[maxn][maxn]; inline void pow(int a[][maxn],int n)&#123; memser(ret,0,sizeof(ret)); for(int i=1;i&lt;=n;i++) ret[i][i]=1; //初始化为单位矩阵 while(n!=0)&#123; if(n&amp;1) multi(ret,a,n); multi(a,a,n); n&gt;&gt;=1; &#125; &#125; 斐波那契数列的矩阵快速幂求斐波那契数列是一个典型的递归过程，但如果所求的n足够大呢？这时候用矩阵快速幂比递归要好。$$Fib(n) =\begin{cases}0, &amp; \text{ $n$=0 } \1, &amp; \text{ $n$=1} \Fib[n-1]+Fib[n-2], &amp; \text{ $n$&gt;1 }\end{cases}$$$\bigl( \begin{smallmatrix} Fib[n] \ Fib[n-1] \end{smallmatrix} \bigr)$ = $\bigl( \begin{smallmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{smallmatrix} \bigr)$ $\bigl( \begin{smallmatrix} Fib[n-1] \ Fib[n-2] \end{smallmatrix} \bigr)$ = $\bigl( \begin{smallmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{smallmatrix} \bigr)^(n-2)$ $\bigl( \begin{smallmatrix} Fib[2] \ Fib[1] \end{smallmatrix} \bigr)$ { Fib[n] } { 1 1 }{ Fib[n-1] } { 1 1 }^(n-1) { Fib[2]=1 } = ={Fib[n-1]} { 1 0 }{ Fib[n-2] } { 1 0 } { Fib[1]=1 }将模板改为结构体即可，注意结构体要记录矩阵的行数和列数（玄学表达，窝相信你们能懂得]]></content>
      <categories>
        <category>算法</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图论】求无向连通图的割点（Tarjan算法）]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%B1%82%E6%97%A0%E5%90%91%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%EF%BC%88Tarjan%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言寒假训练开始了，发现自己真是半灌水响叮当，自己关于割点的概念完全不知道，后来找了几篇不错的博客以及翻了翻白书，白书很适合理解概念，博客给的模板代码适合借鉴。 割点的概念在无向连通图中，如果将其中一个点以及这个点所连的所有的边都去掉，图不再连通，那么这个点成为割点（割顶/关节点）。 如何求割点暴力的方法： 依次删除每一个节点v DFS(BFS)判断是否连通 再把节点v加入图中 若用邻接表，需要做V次DFS，时间复杂度为O(V*(V+E))。 DFS搜索树在介绍Tarjan算法之前，首先需要了解几个基本概念 DFS搜索树：用DFS对图进行遍历时，按照遍历的顺序，可以得到一棵DFS搜索树（图呢？？？ 树边：即父子边，可理解为在DFS过程中访问未访问节点时经过的边 回边：也称反向边，即后代指向祖先的边，可理解为在DFS过程中访问已访问节点时经过的边 Tarjan算法本篇的重点即介绍这一算法，该算法是由R.Tarjan发明的（前人真伟大首先选定一个根节点，从该根节点开始遍历整个图（DFS）思考割点的条件，我们发现有两类节点可以成为割点 对于树根u，当且仅当它有两个或更多的子节点时，它才是割点 对于非根节点u，我们有这样一个定理：在无向连通图G的DFS树中，非根节点u是G的割点当且仅当u存在一个子节点v，使得v及其所有后代都没有反向边连回u的祖先（连回u不算）。 如何解释第二种情况呢？思考若其子节点都没有指向u的祖先的回边，说明删除u之后，根节点与u的子树不再连通，自然也就是割点了。很显然，我们需要解决子节点的回边问题。我们维护两个数组dfn[]和low[]，dfn[u]记录节点u在DFS过程中在第几回被第一次遍历到，low[u]记录节点u以及u的后代通过非父子边能追溯到的最早的祖先的dfn值（即dfn值最小），low[u]的计算过程如下 (u,v)为树边，low[u]=min(low[u],low[v]) (u,v)为回边且v不是u的父亲节点，low[u]=min(low[u],dfn[v]) 当(u,v)为树边且low[v]&gt;=dfn[u]时，节点u为割点。该式子的含义是：以节点v为根的子树所能追溯到最早的祖先要么是v要么是u。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=10000;int dfn[manx],low[maxn],pre[maxn]; //pre[]记录每个节点的祖先，根节点设为-1bool cut[maxn]; //记录该节点是否为割点（因为可能会被重复判断为割点）vector&lt;int&gt; G[maxn];int n,tot; //n为节点数，tot记录割点数量void dfs(int u)&#123; static int cnt=0; //记录dfs的次序 int child=0; dfn[u]=low[u]=++cnt; //默认low[u]=dfn[u] for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; if(!dfn[v])&#123; //第一次访问时dfn值为0（dfn初始化为0） child++; pre[v]=u; dfs(v); low[u]=min(low[u],low[v]); //dfs完毕，如果low[v]&lt;low[u]，则更新low[u]（说明后代v所能追溯到最早的祖先在u之前） if(pre[u]==-1&amp;&amp;child&gt;=2&amp;&amp;!cut[u])&#123; //根节点的子节点多于1，满足割点的第一个条件 cut[u]=true; tot++; &#125;else if(pre[u]!=-1&amp;&amp;low[v]&gt;=dfn[u]&amp;&amp;!cut[u])&#123; //割点的第二个条件 cut[u]=true; tot++; &#125; &#125;else if(v!=pre[u])&#123; //(u,v)为回边，且v不是u的父亲 low[u]=min(low[u],dfn[v]); &#125; &#125;&#125; Tarjan算法的时间复杂度为O(V+E)，即一次DFS就可以求出割点 后话我遇到的第一个求割点的题目是UVA315，抄模板的时候cnt设为了int，结果就wa了（超囧）。 最后感谢这两篇博客割点（Tarjan算法）【图论】求无向连通图的割点]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组不太熟悉，所以下决心写出个教程来，断断续续花了三天（可太断断续续了），听说OI选手最喜欢写树状数组（线段树）了 前言我们将一个数组a[]树状化，每个节点的值C[i]记录了其叶子节点的权值之和，那么树状数组C[]就维护了这个数组a[]的前缀和S[i]=a[1]+a[2]+…+a[i],树状数组利用了二进制，使其可以在O(logn)时间内对这个数组a[]进行修改和求和（与O(n)比起来效率很高） 树状数组可以实现的功能有 将一个数组树状化 区间修改，如改变某一个点a[i]的值 区间查询，如询问a[1]+a[2]+…+a[i]的值 “树状化”数组下面我们来定义C[]数组（也就是把数组树状化）C[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i]，其中k表示i的二进制中末尾0的个数，例如i=8时，二进制为1000，那么C[8]=a[1]+a[2]+…+a[8]，再例如i=6,二进制为110，则C[6]=a[5]+a[6] 我们怎么求这个神奇的k值呢？（可太神奇了不是吗123int lowbit(int i)&#123; return i&amp;(-i);&#125;//实际上最后return的这个i&amp;(-i)=2^k 区间查询每个c[]的定义解决了，接下来我们来看看树状数组的功能之一————区间查询（这里以求前缀和为例），在此之前你的视角应该从十进制转换为二进制比如我们计算sum[7],如果是O(n)的做法，那么就是sum[7]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]，现在我们试试用树状数组的思想来高效化。7对应的二进制是111，我们把111拆分成100+10+1，仔细发现，lowbit(7)=1,7-1=6，lowbit(6)=2(10),6-2=4，lowbit(4)=4(100),4-4=0,那么sum[7]=C[7]+C[6]+C[4]当我们计算sum[7]时，就大大减少了计算次数，时间复杂度降低，也就实现了高效率求前缀和。而计算其他前n项时也是如此，将n的二进制拆分成2^k之和这样的形式，sum[n]=C[n]+C[n-lowbit(n)]+C[n-lowbit(n)-lowbit(n-lowbit(n))]+….,其中这里的lowbit(n)即是前面的2^k下面是求前缀和的代码 12345678int getsum(int pos) &#123; int ans = 0; while (pos != 0) &#123; ans += c[pos]; pos -= lowbit(pos); &#125; return ans;&#125; 同理我们想求得区间和，比如a[i]+a[i+1]+…+a[j]=getsum(j)-getsum(i-1) 区间修改接下来我们来实现区间修改功能（这里以单点更新为例），每次修改时我们更新某个a[i]的值，那么我们便要从这个a[i]节点开始向上不断更新C[]的值（即更新父节点），以保证C[]维护的前缀和保持更新根据前面关于C[]的公式，我们可以发现每个节点i与它的父节点相差lowbit(i)，即C[i]更新了，下一个就要更新C[i+lowbit(i)]（这一步我解释得很生硬，因为我不能很好地解释清楚，只好放结论了）以下是代码部分 123456void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]=x; pos=lowbit(pos); &#125;&#125; 单点更新和区间查询模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int c[100005];int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); update(i,x); &#125; int opt,a,b; for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;opt,&amp;a,&amp;b); if(opt==1) update(a,b); else printf("%d\n",getsum(b)-getsum(a-1)); &#125; &#125; return 0;&#125; 区间修改和单点查询树状数组的单点更新和区间查询功能我们已经实现，接下来我们来实现其他几个功能区间修改和单点查询我们新定义一个差分数组c1[i]=a[i]-a[i-1]，那么a[i]=c1[1]+c1[2]+…+c1[i]，如果我们想把a[i]~a[j]都更新（比如+x），那么只需令c1[i]+=x,c1[j+1]-=x以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int c[100005];int n,m;int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,y-x); x=y; &#125; int opt,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); update(x,k); update(y+1,-k); &#125; else&#123; scanf("%d",&amp;x); printf("%d\n",getsum(x)); &#125; &#125; &#125; return 0;&#125; 区间查询和区间更新观察下列式子a[1]+a[2]+…+a[n]=(c1[1])+(c1[1]+c1[2])+(c1[1]+c1[2]+c1[3])+…+(c1[1]+c1[2]+…+c1[n])=nc1[1]+(n-1)c1[2]+…+c1[n]=n(c1[1]+c1[2]+…+c1[n])-(0c1[1]+1c1[2]+…+(n-1)c1[n])=(n+1)(c1[1]+c1[2]+…+c1[n])-(1c1[1]+2c1[2]+…+nc1[n])那么我们便维护一个数组c2[]，其中c2[i]=i*c[i]，每当我们修改c[]时，同步修改c2[]，总体复杂度还是O(logN)以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int c[100005][2];int n,m;int lowbit(int i)&#123; return i&amp;-i;&#125;int getsum(int pos,int f)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos][f]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int f,int x)&#123; while(pos&lt;=n)&#123; c[pos][f]+=x; pos+=lowbit(pos); &#125;&#125;int ask(int pos)&#123; return (pos+1)*getsum(pos,0)-getsum(pos,1);&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,0,y-x); update(i,1,i*(y-x)); x=y; &#125; int opt,a,b,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;k); update(a,0,k); update(b+1,0,-k); update(a,1,a*k); update(b+1,1,-(b+1)*k); &#125; else&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",ask(b)-ask(a-1)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作总结(一)]]></title>
    <url>%2F2018%2F10%2F10%2FGit%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经久没有使用git（捂脸跑开），今天开会被czq小朋友教做人，所以欸真的需要再回顾一下git操作啊(:зゝ∠)。于是上git官网从头到尾仔仔细细看了一波（不能再废下去了啊喂（摇醒）。也相当于给自己做一个git笔记，以后有忘记的命令操作就来这里看啦。 前言Git是一种分布式版本控制系统，这与常被混淆的Github(只支持Git做版本控制的项目托管平台)是两种不同的概念。在Git中的绝大多数操作都只需要访问本地文件和资源，Git和其他版本控制系统的主要差别在于对待数据的方法，其他大部分系统以文件变更列表的方式存储信息，而Git更像是把数据看作是一组快照，每次提交修改和更新时对这个文件制作一个快照并保存这个快照的索引(其中以文件内容的哈希值来作为索引)。 由于git的使用非常灵活，在实践过程中便衍生出很多种不同的工作流程和协作方式。Git有多种使用方式，强烈建议使用命令行模式。Git安装跳过，请自行使用强大的搜索引擎。 Git基础Git工作流程首先聊聊Git的工作流程，Git有三种状态，你的文件可能处于其中之一 已提交(committed) → 数据已经保存在本地数据库中 已修改(modified) → 修改了文件但还没保存到数据库中 已暂存(staged) → 对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此再引入三个工作区域的概念 Git仓库 → 保存项目的数据 工作目录 → 对项目的某个版本提取出来的内容 暂存区域 → 保存下次将提交的文件列表信息 基本的Git工作流程如下 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照存储到Git仓库 是不是感觉看不懂很头大？那你继续大着看下去吧) Git仓库(Repository)从项目的开始到结尾，我们会接触两种仓库，一种是源仓库(origin), 一种是开发者仓库。源仓库是由项目发起者构建，它汇总了所有参与开发的各个开发者的代码，存放趋于稳定和可发布的代码。当源仓库建立后，开发者应把源仓库”复制”一份，自己的日常开发就在这个复制的仓库进行，即”fork”一下。每个开发者fork的仓库是独立，互不干扰的，而当开发工作完成以后，开发者可以向源仓库发送pull request，请求管理员把自己的代码合并到源仓库中，这样就实现了分布式开发工作(可太分布了不是吗)。 下面讲讲获取Git仓库的两种方法 在现有的目录中初始化比如说我有一个项目目录test，那么我只需要进入该项目目录并输入： 12git init#初始化仓库，该命令将创建一个.git子目录，用来存放初始化的Git仓库中所有的必须文件 注意现在项目的文件还没有被跟踪(被标记)，我们需要 12git add *#跟踪目录下的所有文件，即Git工作流程的第二步 克隆现有的仓库开发者在fork源仓库后就会有一个属于自己的开发者仓库，我们想要把它clone到本地 12git clone git@github.com:yourname/reponamegit#这会在当前目录下创建一个名为reponame的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取所有数据放入.git文件夹，然后读取文件的拷贝 仓库更新我们无非就是对仓库里的文件进行操作，而文件只有两种状态，已追踪和未追踪。Git的操作逻辑是，编辑文件后，它就是一个已修改文件，我们需要把这个文件放入暂存区，然后提交所有暂存区的文件，以此反复。12345git add &lt;filename&gt;#将文件放入暂存区，状态为已追踪git commit -m 'xxxx'#提交暂存区所有的文件，'xxxx'是提交的说明 注意，每次修改后文件都需要放入暂存区，这样才能提交更新后的信息(你也可以理解为git add的意思是添加内容到下一次提交中，如果文件没有被追踪，那么下一次要提交的内容便不包含它) 那么很自然会想到，我们怎么查看文件的状态呢？输入：1git status 可是git status的输出有时候太不友好了，我们迫切地想知道到底修改了那些地方，输入12git diff#比较工作目录中当前文件和暂存区域快照之间的差异，即修改之后没有暂存的文件变化内容 有时候聪明的你也会粗心，忘了把修改后的文件git add了，那么有没有什么命令能解决呢？12git commit -a#把所有已经被跟踪的文件打包暂存然后提交 啊有时候我们想删掉一个文件，但这个文件被追踪过，如果我们只是单纯地删除这个文件，你会发现在未暂存清单里会看见这个文件，这时候输入12git rm &lt;filename&gt;#将文件从暂存区域清除，再从工作目录中删除]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
