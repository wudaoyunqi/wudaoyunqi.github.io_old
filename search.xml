<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[欧拉函数＆欧拉定理＆欧拉降幂]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%86%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%EF%BC%86%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%2F</url>
    <content type="text"><![CDATA[前言上一篇博客我们讲到了快速幂(一般&amp;&amp;矩阵)，现在我们要讲讲一个叫欧拉降幂的东西，为了得到欧拉降幂公式，我们需要回顾一下欧拉函数，再到欧拉定理以及拓展欧拉定理。 欧拉函数公式欧拉函数phi[x],表示[1,x-1]区间中与x互质的数的个数phi[x]=x(1-1/a1)(1-1/a2)…(1-1/an)，其中ai是x的质因数那么就可以得到欧拉函数的一个性质，若p是质数，那么phi[p]=p-1(这一条有时会用到)以及phi[ip]=pphii，phi[ip]=(p-1)*phii 怎么求我们可以用线性筛筛出所有的欧拉函数，首先用线性筛找出[1,n]之间所有的素数，然后根据公式算出欧拉函数值下面是线性筛代码 12345678910111213141516const int maxn = 1e5;int prime[maxn];bool vis[maxn];int tot = 0;void get_prime() &#123; for (int i = 2; i &lt;= maxn; i++) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; i * prime[j] &lt;= maxn &amp;&amp; j &lt;= tot; j++) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 然后是求phi[x]的部分12345678910111213int get_phi(int n) &#123; //求n的欧拉函数值，即phi[n] int ret = n; for (int i = 1; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= n; i++) &#123; if (n % prime[i] == 0) &#123; ret *= (1 - 1 / prime[i]); while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret *= (1 - 1 / n); return ret;&#125; 欧拉定理有了欧拉函数做坚实的后盾，讲欧拉定理就不需要扯那些乱七八糟的东西了(好吧其实是我不会证“整那些干啥，会用就行了。”————鲁迅先扔一个公式，当a,n互质时，a^(phi[n])%n=1，这个公式可以推出a^(phi[n])与n互质(不是废话…似乎不是很直观的样子，那么再换一个a^b(mod n)=a^(b%phi[n])(mod n)(这大概是最有用的公式证明也比较简单，把b表示为phi[n]的一次多项式，即b=x*phi[n]+y，因为有a^(phi[n])%n=1,所以a^b(mod n)=a^y(mod n)=a^(b%phi[n])(mod n)ps:这个公式可以用于欧拉降幂（后面会将 拓展欧拉定理接下来咱们再整个拓展欧拉定理，嗯，拓展大多数情况下不都是从特殊情况推广到一般情况嘛，那咱再整个a,n不互质时有什么样的公式当b&lt;phi[n]时，a^b(mod n)=a^b(mod n);当b&gt;=phi[n]时，a^b(mod n)=a^(b%phi[n]+phi[n])(mod n)证明？不存在的，我还要头发呢！“整那些干啥，会用就行了。” ————鲁迅 欧拉降幂很庆幸，你不用再新推什么奇怪的公式，其实欧拉降幂公式就是欧拉定理和拓展欧拉定理结合起来关于欧拉降幂的应用场景，对于一个问题求a^b(mod n)根据条件把式子转换为三个中的一个好yeah降幂成功惹代码也不给了因为比较简单（不就是求欧拉函数再结合一下快速幂嘛 友情连接：欧拉函数&amp;欧拉定理&amp;降幂 总结(这个网站的mathjax支持好好啊，next自带的辣鸡]]></content>
      <tags>
        <tag>-算法 -欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂（一般＆＆矩阵）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%88%E4%B8%80%E8%88%AC%EF%BC%86%EF%BC%86%E7%9F%A9%E9%98%B5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言其实整个系列弄下来是因为尝试做了小米OJ的二月月赛，结果被狠狠压在地上打(哭，看了评论有人给出的题解，有道题因为涉及到矩阵快速幂，所以干脆把快速幂重新再看一遍。 原理一般朴素的幂积算法计算$a^b$时间复杂度是O(n)，而快速幂可以降到O(logn)，实现的原理是将b二进制化，$b=2^a_{1}+2^a_{2}+…+2^a_{k}$ , $a^b=a^｛2^a_{1}｝a^｛2^a_{2}｝…a^｛2^a_{k}｝$。这些a_{i}就是b的二进制为１的位数(末位取０，从低到高依次增1)，下面是具体实现代码 12345678910long long qpow(long long a, long long b) &#123; long long ret = 1; while (b != 0) &#123; if (b &amp; 1) ret *= a; a *= a; //累乘，以便随时对ret做出贡献 b &gt;&gt;= 1; &#125; return ret;&#125; 代码中我们用到了两种位运算 &amp; 和 &gt;&gt;，&amp;运算用于二进制取位操作，例如b&amp;1就是取二进制的末位，b&amp;1==1?b为奇数:b为偶数；&gt;&gt;运算去掉二进制的最后一位，b&gt;&gt;=1相当于b/2（向下取整） 矩阵快速幂矩阵快速幂是建立在快速幂之上的，只不过将a换成了一个矩阵，所以对于矩阵的相乘我们需要单独写一个函数来实现，以下是代码 1234567891011121314151617181920212223int temp[maxn][maxn]; inline void multi(int a[][maxn],int b[][maxn],int n)&#123; memset(temp,0,sizeof(temp)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) temp[i][j]+=a[i][k]*b[k][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=temp[i][j]; &#125; int ret[maxn][maxn]; inline void pow(int a[][maxn],int n)&#123; memser(ret,0,sizeof(ret)); for(int i=1;i&lt;=n;i++) ret[i][i]=1; //初始化为单位矩阵 while(n!=0)&#123; if(n&amp;1) multi(ret,a,n); multi(a,a,n); n&gt;&gt;=1; &#125; &#125; 斐波那契数列的矩阵快速幂求斐波那契数列是一个典型的递归过程，但如果所求的n足够大呢？这时候用矩阵快速幂比递归要好。$$Fib(n) =\begin{cases}0, &amp; \text{ $n$=0 } \1, &amp; \text{ $n$=1} \Fib[n-1]+Fib[n-2], &amp; \text{ $n$&gt;1 }\end{cases}$$$\bigl( \begin{smallmatrix} Fib[n] \ Fib[n-1] \end{smallmatrix} \bigr)$ = $\bigl( \begin{smallmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{smallmatrix} \bigr)$ $\bigl( \begin{smallmatrix} Fib[n-1] \ Fib[n-2] \end{smallmatrix} \bigr)$ = $\bigl( \begin{smallmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{smallmatrix} \bigr)^(n-2)$ $\bigl( \begin{smallmatrix} Fib[2] \ Fib[1] \end{smallmatrix} \bigr)$ { Fib[n] } { 1 1 }{ Fib[n-1] } { 1 1 }^(n-1) { Fib[2]=1 } = ={Fib[n-1]} { 1 0 }{ Fib[n-2] } { 1 0 } { Fib[1]=1 }将模板改为结构体即可，注意结构体要记录矩阵的行数和列数（玄学表达，窝相信你们能懂得]]></content>
      <tags>
        <tag>-算法 -快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图论】求无向连通图的割点（Tarjan算法）]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%B1%82%E6%97%A0%E5%90%91%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%EF%BC%88Tarjan%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言寒假训练开始了，发现自己真是半灌水响叮当，自己关于割点的概念完全不知道，后来找了几篇不错的博客以及翻了翻白书，白书很适合理解概念，博客给的模板代码适合借鉴。 割点的概念在无向连通图中，如果将其中一个点以及这个点所连的所有的边都去掉，图不再连通，那么这个点成为割点（割顶/关节点）。 如何求割点暴力的方法： 依次删除每一个节点v DFS(BFS)判断是否连通 再把节点v加入图中 若用邻接表，需要做V次DFS，时间复杂度为O(V*(V+E))。 DFS搜索树在介绍Tarjan算法之前，首先需要了解几个基本概念 DFS搜索树：用DFS对图进行遍历时，按照遍历的顺序，可以得到一棵DFS搜索树（图呢？？？ 树边：即父子边，可理解为在DFS过程中访问未访问节点时经过的边 回边：也称反向边，即后代指向祖先的边，可理解为在DFS过程中访问已访问节点时经过的边 Tarjan算法本篇的重点即介绍这一算法，该算法是由R.Tarjan发明的（前人真伟大首先选定一个根节点，从该根节点开始遍历整个图（DFS）思考割点的条件，我们发现有两类节点可以成为割点 对于树根u，当且仅当它有两个或更多的子节点时，它才是割点 对于非根节点u，我们有这样一个定理：在无向连通图G的DFS树中，非根节点u是G的割点当且仅当u存在一个子节点v，使得v及其所有后代都没有反向边连回u的祖先（连回u不算）。 如何解释第二种情况呢？思考若其子节点都没有指向u的祖先的回边，说明删除u之后，根节点与u的子树不再连通，自然也就是割点了。很显然，我们需要解决子节点的回边问题。我们维护两个数组dfn[]和low[]，dfn[u]记录节点u在DFS过程中在第几回被第一次遍历到，low[u]记录节点u以及u的后代通过非父子边能追溯到的最早的祖先的dfn值（即dfn值最小），low[u]的计算过程如下 (u,v)为树边，low[u]=min(low[u],low[v]) (u,v)为回边且v不是u的父亲节点，low[u]=min(low[u],dfn[v]) 当(u,v)为树边且low[v]&gt;=dfn[u]时，节点u为割点。该式子的含义是：以节点v为根的子树所能追溯到最早的祖先要么是v要么是u。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=10000;int dfn[manx],low[maxn],pre[maxn]; //pre[]记录每个节点的祖先，根节点设为-1bool cut[maxn]; //记录该节点是否为割点（因为可能会被重复判断为割点）vector&lt;int&gt; G[maxn];int n,tot; //n为节点数，tot记录割点数量void dfs(int u)&#123; static int cnt=0; //记录dfs的次序 int child=0; dfn[u]=low[u]=++cnt; //默认low[u]=dfn[u] for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; if(!dfn[v])&#123; //第一次访问时dfn值为0（dfn初始化为0） child++; pre[v]=u; dfs(v); low[u]=min(low[u],low[v]); //dfs完毕，如果low[v]&lt;low[u]，则更新low[u]（说明后代v所能追溯到最早的祖先在u之前） if(pre[u]==-1&amp;&amp;child&gt;=2&amp;&amp;!cut[u])&#123; //根节点的子节点多于1，满足割点的第一个条件 cut[u]=true; tot++; &#125;else if(pre[u]!=-1&amp;&amp;low[v]&gt;=dfn[u]&amp;&amp;!cut[u])&#123; //割点的第二个条件 cut[u]=true; tot++; &#125; &#125;else if(v!=pre[u])&#123; //(u,v)为回边，且v不是u的父亲 low[u]=min(low[u],dfn[v]); &#125; &#125;&#125; Tarjan算法的时间复杂度为O(V+E)，即一次DFS就可以求出割点 后话我遇到的第一个求割点的题目是UVA315，抄模板的时候cnt设为了int，结果就wa了（超囧）。 最后感谢这两篇博客割点（Tarjan算法）【图论】求无向连通图的割点]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组不太熟悉，所以下决心写出个教程来，断断续续花了三天（可太断断续续了），听说OI选手最喜欢写树状数组（线段树）了 前言我们将一个数组a[]树状化，每个节点的值C[i]记录了其叶子节点的权值之和，那么树状数组C[]就维护了这个数组a[]的前缀和S[i]=a[1]+a[2]+…+a[i],树状数组利用了二进制，使其可以在O(logn)时间内对这个数组a[]进行修改和求和（与O(n)比起来效率很高） 树状数组可以实现的功能有 将一个数组树状化 区间修改，如改变某一个点a[i]的值 区间查询，如询问a[1]+a[2]+…+a[i]的值 “树状化”数组下面我们来定义C[]数组（也就是把数组树状化）C[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i]，其中k表示i的二进制中末尾0的个数，例如i=8时，二进制为1000，那么C[8]=a[1]+a[2]+…+a[8]，再例如i=6,二进制为110，则C[6]=a[5]+a[6] 我们怎么求这个神奇的k值呢？（可太神奇了不是吗123int lowbit(int i)&#123; return i&amp;(-i);&#125;//实际上最后return的这个i&amp;(-i)=2^k 区间查询每个c[]的定义解决了，接下来我们来看看树状数组的功能之一————区间查询（这里以求前缀和为例），在此之前你的视角应该从十进制转换为二进制比如我们计算sum[7],如果是O(n)的做法，那么就是sum[7]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]，现在我们试试用树状数组的思想来高效化。7对应的二进制是111，我们把111拆分成100+10+1，仔细发现，lowbit(7)=1,7-1=6，lowbit(6)=2(10),6-2=4，lowbit(4)=4(100),4-4=0,那么sum[7]=C[7]+C[6]+C[4]当我们计算sum[7]时，就大大减少了计算次数，时间复杂度降低，也就实现了高效率求前缀和。而计算其他前n项时也是如此，将n的二进制拆分成2^k之和这样的形式，sum[n]=C[n]+C[n-lowbit(n)]+C[n-lowbit(n)-lowbit(n-lowbit(n))]+….,其中这里的lowbit(n)即是前面的2^k下面是求前缀和的代码 12345678int getsum(int pos) &#123; int ans = 0; while (pos != 0) &#123; ans += c[pos]; pos -= lowbit(pos); &#125; return ans;&#125; 同理我们想求得区间和，比如a[i]+a[i+1]+…+a[j]=getsum(j)-getsum(i-1) 区间修改接下来我们来实现区间修改功能（这里以单点更新为例），每次修改时我们更新某个a[i]的值，那么我们便要从这个a[i]节点开始向上不断更新C[]的值（即更新父节点），以保证C[]维护的前缀和保持更新根据前面关于C[]的公式，我们可以发现每个节点i与它的父节点相差lowbit(i)，即C[i]更新了，下一个就要更新C[i+lowbit(i)]（这一步我解释得很生硬，因为我不能很好地解释清楚，只好放结论了）以下是代码部分 123456void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]=x; pos=lowbit(pos); &#125;&#125; 单点更新和区间查询模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int c[100005];int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); update(i,x); &#125; int opt,a,b; for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;opt,&amp;a,&amp;b); if(opt==1) update(a,b); else printf("%d\n",getsum(b)-getsum(a-1)); &#125; &#125; return 0;&#125; 区间修改和单点查询树状数组的单点更新和区间查询功能我们已经实现，接下来我们来实现其他几个功能区间修改和单点查询我们新定义一个差分数组c1[i]=a[i]-a[i-1]，那么a[i]=c1[1]+c1[2]+…+c1[i]，如果我们想把a[i]~a[j]都更新（比如+x），那么只需令c1[i]+=x,c1[j+1]-=x以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int c[100005];int n,m;int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,y-x); x=y; &#125; int opt,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); update(x,k); update(y+1,-k); &#125; else&#123; scanf("%d",&amp;x); printf("%d\n",getsum(x)); &#125; &#125; &#125; return 0;&#125; 区间查询和区间更新观察下列式子a[1]+a[2]+…+a[n]=(c1[1])+(c1[1]+c1[2])+(c1[1]+c1[2]+c1[3])+…+(c1[1]+c1[2]+…+c1[n])=nc1[1]+(n-1)c1[2]+…+c1[n]=n(c1[1]+c1[2]+…+c1[n])-(0c1[1]+1c1[2]+…+(n-1)c1[n])=(n+1)(c1[1]+c1[2]+…+c1[n])-(1c1[1]+2c1[2]+…+nc1[n])那么我们便维护一个数组c2[]，其中c2[i]=i*c[i]，每当我们修改c[]时，同步修改c2[]，总体复杂度还是O(logN)以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int c[100005][2];int n,m;int lowbit(int i)&#123; return i&amp;-i;&#125;int getsum(int pos,int f)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos][f]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int f,int x)&#123; while(pos&lt;=n)&#123; c[pos][f]+=x; pos+=lowbit(pos); &#125;&#125;int ask(int pos)&#123; return (pos+1)*getsum(pos,0)-getsum(pos,1);&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,0,y-x); update(i,1,i*(y-x)); x=y; &#125; int opt,a,b,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;k); update(a,0,k); update(b+1,0,-k); update(a,1,a*k); update(b+1,1,-(b+1)*k); &#125; else&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",ask(b)-ask(a-1)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作总结(一)]]></title>
    <url>%2F2018%2F10%2F10%2FGit%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经久没有使用git（捂脸跑开），今天开会被czq小朋友教做人，所以欸真的需要再回顾一下git操作啊(:зゝ∠)。于是上git官网从头到尾仔仔细细看了一波（不能再废下去了啊喂（摇醒）。也相当于给自己做一个git笔记，以后有忘记的命令操作就来这里看啦。 前言Git是一种分布式版本控制系统，这与常被混淆的Github(只支持Git做版本控制的项目托管平台)是两种不同的概念。在Git中的绝大多数操作都只需要访问本地文件和资源，Git和其他版本控制系统的主要差别在于对待数据的方法，其他大部分系统以文件变更列表的方式存储信息，而Git更像是把数据看作是一组快照，每次提交修改和更新时对这个文件制作一个快照并保存这个快照的索引(其中以文件内容的哈希值来作为索引)。 由于git的使用非常灵活，在实践过程中便衍生出很多种不同的工作流程和协作方式。Git有多种使用方式，强烈建议使用命令行模式。Git安装跳过，请自行使用强大的搜索引擎。 Git基础Git工作流程首先聊聊Git的工作流程，Git有三种状态，你的文件可能处于其中之一 已提交(committed) → 数据已经保存在本地数据库中 已修改(modified) → 修改了文件但还没保存到数据库中 已暂存(staged) → 对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此再引入三个工作区域的概念 Git仓库 → 保存项目的数据 工作目录 → 对项目的某个版本提取出来的内容 暂存区域 → 保存下次将提交的文件列表信息 基本的Git工作流程如下 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照存储到Git仓库 是不是感觉看不懂很头大？那你继续大着看下去吧) Git仓库(Repository)从项目的开始到结尾，我们会接触两种仓库，一种是源仓库(origin), 一种是开发者仓库。源仓库是由项目发起者构建，它汇总了所有参与开发的各个开发者的代码，存放趋于稳定和可发布的代码。当源仓库建立后，开发者应把源仓库”复制”一份，自己的日常开发就在这个复制的仓库进行，即”fork”一下。每个开发者fork的仓库是独立，互不干扰的，而当开发工作完成以后，开发者可以向源仓库发送pull request，请求管理员把自己的代码合并到源仓库中，这样就实现了分布式开发工作(可太分布了不是吗)。 下面讲讲获取Git仓库的两种方法 在现有的目录中初始化比如说我有一个项目目录test，那么我只需要进入该项目目录并输入： 12git init#初始化仓库，该命令将创建一个.git子目录，用来存放初始化的Git仓库中所有的必须文件 注意现在项目的文件还没有被跟踪(被标记)，我们需要 12git add *#跟踪目录下的所有文件，即Git工作流程的第二步 克隆现有的仓库开发者在fork源仓库后就会有一个属于自己的开发者仓库，我们想要把它clone到本地 12git clone git@github.com:yourname/reponamegit#这会在当前目录下创建一个名为reponame的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取所有数据放入.git文件夹，然后读取文件的拷贝 仓库更新我们无非就是对仓库里的文件进行操作，而文件只有两种状态，已追踪和未追踪。Git的操作逻辑是，编辑文件后，它就是一个已修改文件，我们需要把这个文件放入暂存区，然后提交所有暂存区的文件，以此反复。12345git add &lt;filename&gt;#将文件放入暂存区，状态为已追踪git commit -m 'xxxx'#提交暂存区所有的文件，'xxxx'是提交的说明 注意，每次修改后文件都需要放入暂存区，这样才能提交更新后的信息(你也可以理解为git add的意思是添加内容到下一次提交中，如果文件没有被追踪，那么下一次要提交的内容便不包含它) 那么很自然会想到，我们怎么查看文件的状态呢？输入：1git status 可是git status的输出有时候太不友好了，我们迫切地想知道到底修改了那些地方，输入12git diff#比较工作目录中当前文件和暂存区域快照之间的差异，即修改之后没有暂存的文件变化内容 有时候聪明的你也会粗心，忘了把修改后的文件git add了，那么有没有什么命令能解决呢？12git commit -a#把所有已经被跟踪的文件打包暂存然后提交 啊有时候我们想删掉一个文件，但这个文件被追踪过，如果我们只是单纯地删除这个文件，你会发现在未暂存清单里会看见这个文件，这时候输入12git rm &lt;filename&gt;#将文件从暂存区域清除，再从工作目录中删除]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
