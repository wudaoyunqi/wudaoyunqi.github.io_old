<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组不太熟悉，所以下决心写出个教程来，断断续续花了三天（可太断断续续了），听说OI选手最喜欢写树状数组（线段树）了 前言我们将一个数组a[]树状化，每个节点的值C[i]记录了其叶子节点的权值之和，那么树状数组C[]就维护了这个数组a[]的前缀和S[i]=a[1]+a[2]+…+a[i],树状数组利用了二进制，使其可以在O(logn)时间内对这个数组a[]进行修改和求和（与O(n)比起来效率很高） 树状数组可以实现的功能有 将一个数组树状化 区间修改，如改变某一个点a[i]的值 区间查询，如询问a[1]+a[2]+…+a[i]的值 “树状化”数组下面我们来定义C[]数组（也就是把数组树状化）C[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i]，其中k表示i的二进制中末尾0的个数，例如i=8时，二进制为1000，那么C[8]=a[1]+a[2]+…+a[8]，再例如i=6,二进制为110，则C[6]=a[5]+a[6] 我们怎么求这个神奇的k值呢？（可太神奇了不是吗123int lowbit(int i)&#123; return i&amp;(-i);&#125;//实际上最后return的这个i&amp;(-i)=2^k 区间查询每个c[]的定义解决了，接下来我们来看看树状数组的功能之一————区间查询（这里以求前缀和为例），在此之前你的视角应该从十进制转换为二进制比如我们计算sum[7],如果是O(n)的做法，那么就是sum[7]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]，现在我们试试用树状数组的思想来高效化。7对应的二进制是111，我们把111拆分成100+10+1，仔细发现，lowbit(7)=1,7-1=6，lowbit(6)=2(10),6-2=4，lowbit(4)=4(100),4-4=0,那么sum[7]=C[7]+C[6]+C[4]当我们计算sum[7]时，就大大减少了计算次数，时间复杂度降低，也就实现了高效率求前缀和。而计算其他前n项时也是如此，将n的二进制拆分成2^k之和这样的形式，sum[n]=C[n]+C[n-lowbit(n)]+C[n-lowbit(n)-lowbit(n-lowbit(n))]+….,其中这里的lowbit(n)即是前面的2^k下面是求前缀和的代码 12345678int getsum(int pos) &#123; int ans = 0; while (pos != 0) &#123; ans += c[pos]; pos -= lowbit(pos); &#125; return ans;&#125; 同理我们想求得区间和，比如a[i]+a[i+1]+…+a[j]=getsum(j)-getsum(i-1) 区间修改接下来我们来实现区间修改功能（这里以单点更新为例），每次修改时我们更新某个a[i]的值，那么我们便要从这个a[i]节点开始向上不断更新C[]的值（即更新父节点），以保证C[]维护的前缀和保持更新根据前面关于C[]的公式，我们可以发现每个节点i与它的父节点相差lowbit(i)，即C[i]更新了，下一个就要更新C[i+lowbit(i)]（这一步我解释得很生硬，因为我不能很好地解释清楚，只好放结论了）以下是代码部分 123456void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]=x; pos=lowbit(pos); &#125;&#125; 单点更新和区间查询模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int c[100005];int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); update(i,x); &#125; int opt,a,b; for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;opt,&amp;a,&amp;b); if(opt==1) update(a,b); else printf("%d\n",getsum(b)-getsum(a-1)); &#125; &#125; return 0;&#125; 区间修改和单点查询树状数组的单点更新和区间查询功能我们已经实现，接下来我们来实现其他几个功能区间修改和单点查询我们新定义一个差分数组c1[i]=a[i]-a[i-1]，那么a[i]=c1[1]+c1[2]+…+c1[i]，如果我们想把a[i]~a[j]都更新（比如+x），那么只需令c1[i]+=x,c1[j+1]-=x以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int c[100005];int n,m;int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,y-x); x=y; &#125; int opt,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); update(x,k); update(y+1,-k); &#125; else&#123; scanf("%d",&amp;x); printf("%d\n",getsum(x)); &#125; &#125; &#125; return 0;&#125; 区间查询和区间更新观察下列式子a[1]+a[2]+…+a[n]=(c1[1])+(c1[1]+c1[2])+(c1[1]+c1[2]+c1[3])+…+(c1[1]+c1[2]+…+c1[n])=nc1[1]+(n-1)c1[2]+…+c1[n]=n(c1[1]+c1[2]+…+c1[n])-(0c1[1]+1c1[2]+…+(n-1)c1[n])=(n+1)(c1[1]+c1[2]+…+c1[n])-(1c1[1]+2c1[2]+…+nc1[n])那么我们便维护一个数组c2[]，其中c2[i]=i*c[i]，每当我们修改c[]时，同步修改c2[]，总体复杂度还是O(logN)以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int c[100005][2];int n,m;int lowbit(int i)&#123; return i&amp;-i;&#125;int getsum(int pos,int f)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos][f]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int f,int x)&#123; while(pos&lt;=n)&#123; c[pos][f]+=x; pos+=lowbit(pos); &#125;&#125;int ask(int pos)&#123; return (pos+1)*getsum(pos,0)-getsum(pos,1);&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,0,y-x); update(i,1,i*(y-x)); x=y; &#125; int opt,a,b,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;k); update(a,0,k); update(b+1,0,-k); update(a,1,a*k); update(b+1,1,-(b+1)*k); &#125; else&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",ask(b)-ask(a-1)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作总结(一)]]></title>
    <url>%2F2018%2F10%2F10%2FGit%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经久没有使用git（捂脸跑开），今天开会被czq小朋友教做人，所以欸真的需要再回顾一下git操作啊(:зゝ∠)。于是上git官网从头到尾仔仔细细看了一波（不能再废下去了啊喂（摇醒）。也相当于给自己做一个git笔记，以后有忘记的命令操作就来这里看啦。 前言Git是一种分布式版本控制系统，这与常被混淆的Github(只支持Git做版本控制的项目托管平台)是两种不同的概念。在Git中的绝大多数操作都只需要访问本地文件和资源，Git和其他版本控制系统的主要差别在于对待数据的方法，其他大部分系统以文件变更列表的方式存储信息，而Git更像是把数据看作是一组快照，每次提交修改和更新时对这个文件制作一个快照并保存这个快照的索引(其中以文件内容的哈希值来作为索引)。 由于git的使用非常灵活，在实践过程中便衍生出很多种不同的工作流程和协作方式。Git有多种使用方式，强烈建议使用命令行模式。Git安装跳过，请自行使用强大的搜索引擎。 Git基础Git工作流程首先聊聊Git的工作流程，Git有三种状态，你的文件可能处于其中之一 已提交(committed) → 数据已经保存在本地数据库中 已修改(modified) → 修改了文件但还没保存到数据库中 已暂存(staged) → 对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此再引入三个工作区域的概念 Git仓库 → 保存项目的数据 工作目录 → 对项目的某个版本提取出来的内容 暂存区域 → 保存下次将提交的文件列表信息 基本的Git工作流程如下 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照存储到Git仓库 是不是感觉看不懂很头大？那你继续大着看下去吧) Git仓库(Repository)从项目的开始到结尾，我们会接触两种仓库，一种是源仓库(origin), 一种是开发者仓库。源仓库是由项目发起者构建，它汇总了所有参与开发的各个开发者的代码，存放趋于稳定和可发布的代码。当源仓库建立后，开发者应把源仓库”复制”一份，自己的日常开发就在这个复制的仓库进行，即”fork”一下。每个开发者fork的仓库是独立，互不干扰的，而当开发工作完成以后，开发者可以向源仓库发送pull request，请求管理员把自己的代码合并到源仓库中，这样就实现了分布式开发工作(可太分布了不是吗)。 下面讲讲获取Git仓库的两种方法 在现有的目录中初始化比如说我有一个项目目录test，那么我只需要进入该项目目录并输入： 12git init#初始化仓库，该命令将创建一个.git子目录，用来存放初始化的Git仓库中所有的必须文件 注意现在项目的文件还没有被跟踪(被标记)，我们需要 12git add *#跟踪目录下的所有文件，即Git工作流程的第二步 克隆现有的仓库开发者在fork源仓库后就会有一个属于自己的开发者仓库，我们想要把它clone到本地 12git clone git@github.com:yourname/reponamegit#这会在当前目录下创建一个名为reponame的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取所有数据放入.git文件夹，然后读取文件的拷贝 仓库更新我们无非就是对仓库里的文件进行操作，而文件只有两种状态，已追踪和未追踪。Git的操作逻辑是，编辑文件后，它就是一个已修改文件，我们需要把这个文件放入暂存区，然后提交所有暂存区的文件，以此反复。12345git add &lt;filename&gt;#将文件放入暂存区，状态为已追踪git commit -m 'xxxx'#提交暂存区所有的文件，'xxxx'是提交的说明 注意，每次修改后文件都需要放入暂存区，这样才能提交更新后的信息(你也可以理解为git add的意思是添加内容到下一次提交中，如果文件没有被追踪，那么下一次要提交的内容便不包含它) 那么很自然会想到，我们怎么查看文件的状态呢？输入：1git status 可是git status的输出有时候太不友好了，我们迫切地想知道到底修改了那些地方，输入12git diff#比较工作目录中当前文件和暂存区域快照之间的差异，即修改之后没有暂存的文件变化内容 有时候聪明的你也会粗心，忘了把修改后的文件git add了，那么有没有什么命令能解决呢？12git commit -a#把所有已经被跟踪的文件打包暂存然后提交 啊有时候我们想删掉一个文件，但这个文件被追踪过，如果我们只是单纯地删除这个文件，你会发现在未暂存清单里会看见这个文件，这时候输入12git rm &lt;filename&gt;#将文件从暂存区域清除，再从工作目录中删除]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
