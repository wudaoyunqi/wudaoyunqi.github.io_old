<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NEUOJ-2Monthly-3]]></title>
    <url>%2F2019%2F05%2F05%2FNEUOJ-2Monthly-3%2F</url>
    <content type="text"><![CDATA[题目网址：https://oj.neu.edu.cn/problem/1467 思路求x出现了几次，当然是将所有编号踢入一个数组，然后用lower_bound和upper_bound寻找前后位置（目前二分很容易写错，stl大法好 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//// Created by yunqi on 19-2-17.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;namespace fastIO &#123;#define BUF_SIZE 100000 //fread -&gt; read bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE; if (p1 == pend) &#123; p1 = buf; pend = buf + fread(buf, 1, BUF_SIZE, stdin); if (pend == p1) &#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank(char ch) &#123; return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; &#125; inline void read(int &amp;x) &#123; char ch; while (blank(ch = nc())); if (IOerror) return; for (x = ch - '0'; (ch = nc()) &gt;= '0' &amp;&amp; ch &lt;= '9'; x = x * 10 + ch - '0'); &#125; inline void readll(long long int &amp;x) &#123; char ch; while (blank(ch = nc())); if (IOerror) return; for (x = ch - '0'; (ch = nc()) &gt;= '0' &amp;&amp; ch &lt;= '9'; x = x * 10 + ch - '0'); &#125;#undef BUF_SIZE&#125;;using namespace std;using namespace fastIO;const int maxn = 1e5 + 10;long long a[maxn];int main(void) &#123; int t; read(t); while (t--) &#123; int n, q; read(n); read(q); for (int i = 1; i &lt;= n; i++) readll(a[i]); sort(a + 1, a + n + 1); while (q--) &#123; long long x; readll(x); unsigned long l = lower_bound(a + 1, a + n + 1, x) - a; unsigned long r = upper_bound(a + 1, a + n + 1, x) - a; printf("%ld\n", r - l); &#125; &#125; return 0;&#125; 做题感受寒假刚好对lower_bound和upper_bound掌握得很熟练，所以看到这道题马上就想出来了，并且也意识到暴力是会t的：）这一次快读会用了，体验很好，只可惜我做出三题后明显显露疲惫之态，导致第四道很多人都做出来了我却木有quq，我干啥去了？咸鱼去了啊]]></content>
      <categories>
        <category>NEUOJ</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>NEUOJ</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEUOJ-2Monthly-2]]></title>
    <url>%2F2019%2F05%2F05%2FNEUOJ-2Monthly-2%2F</url>
    <content type="text"><![CDATA[题目地址：https://oj.neu.edu.cn/problem/1466 思路通过找规律发现，只有素数或者质因子分解形式为两个质数（指数为１）的积的合数不符合题目条件。那么可以先预处理出1e6范围内的符合条件的结果，然后再用lower_bound查找n的位置就行。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//// Created by yunqi on 19-2-17.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1e6 + 10;int prime[80000], ans[maxn];bool vis[maxn];int cnt = 0, tot = 0;void get_prime() &#123; for (int i = 2; i &lt;= maxn; i++) &#123; if (!vis[i]) prime[++cnt] = i; for (int j = 1; i * prime[j] &lt;= maxn &amp;&amp; j &lt;= cnt; j++) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;void judge_factor() &#123; for (int i = 4; i &lt;= maxn; i++) &#123; if (!vis[i]) //素数 continue; int temp = i, sum2 = 0 ,judge=false; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * prime[j] &lt;= temp; j++) &#123; if (temp % prime[j] == 0) &#123; sum2++; int sum1 = 0; while (temp % prime[j] == 0) &#123; temp /= prime[j]; sum1++; &#125; if (sum1 &gt; 1) &#123; ans[++tot] = i;// printf("%d\n", i); judge=true; break; &#125; &#125; &#125; if (temp &gt; 1) sum2++; if (sum2 &gt; 2 &amp;&amp; !judge) ans[++tot] = i; &#125;// printf("%d\n", tot);&#125;int main(void) &#123; int t; get_prime(); judge_factor(); while (~scanf("%d", &amp;t)) &#123; while (t--) &#123; int n; scanf("%d", &amp;n); unsigned long pos = lower_bound(ans + 1, ans + tot + 1, n) - ans; if (ans[pos] &gt; n) pos--; printf("%ld\n", pos); &#125; &#125; return 0;&#125; ## 做题感受 当时推了有将近一个多个小时orz，比赛过了两个小时才ac]]></content>
      <categories>
        <category>NEUOJ</category>
        <category>规律</category>
      </categories>
      <tags>
        <tag>NEUOJ</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEUOJ-1Monthly-2]]></title>
    <url>%2F2019%2F05%2F05%2FNEUOJ-1Monthly-2%2F</url>
    <content type="text"><![CDATA[题目地址：https://oj.neu.edu.cn/problem/1460 思路任何一个整数都可以表示为n=p1^a1p2^a2…pn^an，则f(n,0)=a1a2…an，f(n,0)是积性函数（自己手推一下），对于f(x,y)是f(x,y-1)与自身进行狄利克雷卷积得到的结果，所以f(x,y)也是积性函数（这一点没有想通，等之后深挖狄利克雷卷积再填坑），所以f(x,y)也是积性函数。因此，只要对n质因子分解，然后预处理次方的dp值就可以了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//// Created by Yunqi on 19-4-18 下午7:30.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#define mod 1000000007typedef long long ll;using namespace std;const int maxn = 1e6 + 10;ll prime[maxn];ll dp[30][10010]; //次方幂dpbool vis[maxn];void get_prime() &#123; int cnt = 0; for (ll i = 2; i &lt; maxn; ++i) &#123; if (!vis[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; prime[j] * i &lt; maxn; ++j) &#123; vis[prime[j] * i] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;void get_dp() &#123; //计算次方幂的dp for (ll i = 1; i &lt; 30; ++i) dp[i][0] = i; for (int i = 1; i &lt; 30; ++i) &#123; for (int j = 1; j &lt;= 10000; ++j) &#123; if (i == 1) &#123; dp[i][j] = dp[i][j - 1] * 2 % mod; &#125; else &#123; dp[i][j] = dp[i][j - 1] * 2 % mod; for (int k = 1; k &lt; i; ++k) dp[i][j] = (dp[i][j] + dp[k][j - 1] * dp[i - k][j - 1] % mod) % mod; &#125; &#125; &#125;&#125;ll get_factor(ll x, ll m) &#123; //分解质因数 ll ret = 1; if (!vis[x]) return dp[1][m] % mod; for (int i = 1; prime[i] * prime[i] &lt;= x; ++i) &#123; if (x % prime[i] == 0) &#123; int cnt = 0; while (x % prime[i] == 0) &#123; x /= prime[i]; ++cnt; &#125; ret = (ret * dp[cnt][m]) % mod; &#125; &#125; if (x &gt; 1LL) ret = (ret * dp[1][m]) % mod; return ret;&#125;int main() &#123; get_prime(); get_dp(); int t; while(~scanf("%d", &amp;t)) &#123; while (t--) &#123; ll n, m; scanf("%lld%lld", &amp;n, &amp;m); printf("%lld\n", get_factor(n, m)); &#125; &#125; return 0;&#125; 做题感受前前后后花了两天，先开始问了邱学弟dp的做法，然后他提点了一下我，我在纸上推了好久，有点思路了，写了初步的解法（先开始关于次方的dp没有推出来，或者说没有想到次方那里去…），后来发现样例都过不了。于是去找杨博学长问问，才发现我蠢到连取模都忘了orx，加了还是t，然后杨博学长说分解质因数时如果是素数就直接返回（优化），我加上从t到wa。杨博学长开始盲目debug，说取模会有负数这一情况让我改改，我改了还是wa。囧最后还是问了邱学弟，他看了一下说n=1时结果好像不太对，我特判了一下，最后终于ac了！当时抓狂想把杨博学长祭天qaq]]></content>
      <categories>
        <category>NEUOJ</category>
        <category>积性函数</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>NEUOJ</tag>
        <tag>积性函数</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEUOJ-1Monthly-1]]></title>
    <url>%2F2019%2F05%2F05%2FNEUOJ-1Monthly-1%2F</url>
    <content type="text"><![CDATA[题目地址：https://oj.neu.edu.cn/problem/1459 思路三种做法，１、三次lowbit ２、三次x=x&amp;(x-1) 3、__builtin_popcountll（计算一个64位无符号整数的二进制有多少个位为１） 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// Created by Yunqi on 19-4-17 下午11:13.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;namespace fastIO &#123;#define BUF_SIZE 100000 bool IOerror = 0; inline char nc() &#123; static char buf[BUF_SIZE], *p1 = buf + BUF_SIZE, *pend = buf + BUF_SIZE; if (p1 == pend) &#123; p1 = buf; pend = buf + fread(buf, 1, BUF_SIZE, stdin); if (pend == p1) &#123; IOerror = 1; return -1; &#125; &#125; return *p1++; &#125; inline bool blank(char ch) &#123; return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; &#125; inline void read(long long int &amp;x) &#123; char ch; while (blank(ch = nc())); if (IOerror) return; for (x = ch - '0'; (ch = nc()) &gt;= '0' &amp;&amp; ch &lt;= '9'; x = x * 10 + ch - '0'); &#125;#undef BUF_SIZE&#125;;using namespace fastIO;int main() &#123; long long t; read(t); while (t--) &#123; long long n; read(n); for (int i = 1; i &lt;= 3 &amp;&amp; n; ++i) &#123; long long com = n &amp; (-n); n -= com; &#125; if (n == 0) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; 做题感受第一次遇见自己写一个命名空间（快读部分），所以先开始都不知道怎么用快读==，那一次校赛就爆０了（也是我心不在焉地做题的锅。后来杰霸吐槽这么多只有邱学弟一个人写出了正解，才知道不能单纯地暴力做，要用位运算。lowbit就是求x的最低位１的位置，计算方法是x&amp;-x，运用了补码原理，而x=x&amp;(x-1)相当于将x最右边的１消除。位运算真的很深……，在写树状数组的博客时也提到这一点，以后有空专门补补这方面的知识]]></content>
      <categories>
        <category>NEUOJ</category>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>NEUOJ</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江省赛19th-Robot_Cleaner_I]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B19th-Robot-Cleaner-I%2F</url>
    <content type="text"><![CDATA[题目地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=5981 思路按照题意模拟即可，有三处剪枝，一是获得的字母数＞字母总数时剪枝，二是给每个点对应一个哈希坐标，记录这个坐标是否在某几个x值循环（这一点比较难想，很容易t），三是只要处于do nothing状态就break 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// Created by neuacm on 4/20/19.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;const int maxn = 2010;char s[maxn], type[20000][2000];int vis[maxn * 10][300];int n, m, a, b;long long k;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d%d", &amp;n, &amp;m); scanf("%d%d%lld", &amp;a, &amp;b, &amp;k); scanf("%s", s + 1); for (int i = 1; i &lt;= n; ++i) scanf("%s", type[i] + 1); int ans = 0, sum = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) if (type[i][j] == '2') sum++; memset(vis, -1, sizeof(vis)); while (k--) &#123; if (ans == sum) break; int x = 81 * (type[a][b] - '0') + 27 * (type[a - 1][b] - '0') + 9 * (type[a + 1][b] - '0') + 3 * (type[a][b - 1] - '0') + type[a][b + 1] - '0'; if (vis[(a - 1) * m + b][x] == ans) break; vis[(a - 1) * m + b][x] = ans; if (s[x + 1] == 'U' &amp;&amp; type[a - 1][b] != '1') a--; else if (s[x + 1] == 'D' &amp;&amp; type[a + 1][b] != '1') a++; else if (s[x + 1] == 'L' &amp;&amp; type[a][b - 1] != '1') b--; else if (s[x + 1] == 'R' &amp;&amp; type[a][b + 1] != '1') b++; else if (s[x + 1] == 'P' &amp;&amp; type[a][b] == '2') &#123; ans++; type[a][b] = '0'; &#125; else break; &#125; printf("%d\n", ans); &#125; return 0;&#125; 做题感受开始一直t，愣是没想到第二个剪枝，因为k太大所以当然会t啦……，看题解有另一个剪枝的方法，一个位置不会被访问超过n*m次，总共4e8的复杂度也能过]]></content>
      <categories>
        <category>浙江省赛</category>
        <category>哈希</category>
      </categories>
      <tags>
        <tag>浙江省赛</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江省赛19th-Extended_Twin_Composite_Number]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B19th-Extended-Twin-Composite-Number%2F</url>
    <content type="text"><![CDATA[题目地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4099 思路n2+n=n3 代码12345678910111213141516171819202122232425//// Created by neuacm on 4/20/19.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main(void) &#123; int t; while (~scanf("%d", &amp;t)) &#123; while (t--) &#123; long long n; scanf("%lld", &amp;n); if(n==1) printf("%d %d\n",8,9); else printf("%lld %lld\n",n*2,n*3); &#125; &#125; return 0;&#125; 做题感受海星]]></content>
      <categories>
        <category>浙江省赛</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>浙江省赛</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江省赛19th-Potion]]></title>
    <url>%2F2019%2F05%2F05%2F%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B19th-Potion%2F</url>
    <content type="text"><![CDATA[题目地址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4094 思路因为只能从rank高的（分给）rank低的，所以从n开始依次将bi置为ai，bi-1+=(bi-ai)，如果bi&lt;ai，那么输出No,否则输出Yes 代码123456789101112131415161718192021222324252627282930#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;long long a[110],b[110];int main(void)&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;b[i]); bool jduge=true; for(int i=n;i&gt;=1;--i)&#123; if(b[i]&lt;a[i])&#123; jduge=false; break; &#125; b[i-1]+=(b[i]-a[i]); &#125; if(!jduge) printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; 做题感受海星]]></content>
      <tags>
        <tag>浙江省赛</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江省赛19th-Thanks,TuSimple!]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B19th-Thanks_TuSimple%2F</url>
    <content type="text"><![CDATA[题目网址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4090 思路首先根据pi的值从小到大排序，同一个pi值按身高从低到高排序，然后线性匹配。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 1e5 + 10;struct Node &#123; int high; int like; bool operator&lt;(const Node &amp;a) const &#123; if (like == a.like) return high &lt; a.high; else return like &lt; a.like; &#125;&#125; a[maxn], b[maxn];int main(void) &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i].high); for (int i = 1; i &lt;= m; ++i) scanf("%d", &amp;b[i].high); for (int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i].like); for (int i = 1; i &lt;= m; ++i) scanf("%d", &amp;b[i].like); sort(a + 1, a + n + 1); sort(b + 1, b + m + 1); int ans = 0, pos = m + 1; for (int i = 1; i &lt;= m; ++i) &#123; if (b[i].like) &#123; pos = i; break; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (pos &gt; m) break; if (!a[i].like &amp;&amp; a[i].high &gt; b[pos].high) &#123; ans++; pos++; &#125; &#125; pos = n + 1; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].like) &#123; pos = i; break; &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; if (pos &gt; n) break; if (!b[i].like &amp;&amp; a[pos].high &lt; b[i].high) &#123; ans++; pos++; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; 这是比赛完搜题解的时候自己改换了思路，原先比赛时写的代码巨tm复杂，都想出二分答案了，还不停地转了转去…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;struct Like&#123; int high; int like;&#125;male[100010],female[100010];vector&lt;int&gt; malehigh,maleshort,femalehigh,femaleshort;bool cmp1(const int &amp;a,const int &amp;b)&#123; return a&gt;b;&#125;bool cmp2(const int &amp;a,const int &amp;b)&#123; return a&lt;b;&#125;int main(void)&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); maleshort.clear(),malehigh.clear(),femaleshort.clear(),femalehigh.clear(); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;male[i].high); for(int i=1;i&lt;=m;++i) scanf("%d",&amp;female[i].high); for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;male[i].like); if(male[i].like==0) maleshort.push_back(male[i].high); else malehigh.push_back(male[i].high); &#125; for(int i=1;i&lt;=m;++i)&#123; scanf("%d",&amp;female[i].like); if(female[i].like==0) femaleshort.push_back(female[i].high); else femalehigh.push_back(female[i].high); &#125; sort(maleshort.begin(),maleshort.end(),cmp1); sort(malehigh.begin(),malehigh.end(),cmp2); sort(femaleshort.begin(),femaleshort.end(),cmp1); sort(femalehigh.begin(),femalehigh.end(),cmp2); int ans=0; for(int i=0;i&lt;maleshort.size()&amp;&amp;!femaleshort.empty();++i)&#123; vector&lt;int&gt;::iterator k=lower_bound(femalehigh.begin(),femalehigh.end(),maleshort[i]); if(k==femalehigh.begin()) continue; if(k==femalehigh.end())&#123; ans++; femalehigh.erase(femalehigh.end()-1); &#125;else&#123; ans++; femalehigh.erase(k-1); &#125; &#125; for(int i=0;i&lt;femaleshort.size()&amp;&amp;!malehigh.empty();++i)&#123; vector&lt;int&gt;::iterator k=lower_bound(malehigh.begin(),malehigh.end(),femaleshort[i]); if(k==malehigh.begin()) continue; if(k==malehigh.end())&#123; ans++; malehigh.erase(malehigh.end()-1); &#125;else&#123; ans++; malehigh.erase(k-1); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; 做题感受比赛时脑子不清醒，想得太复杂]]></content>
      <categories>
        <category>浙江省赛</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>浙江省赛</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙江省赛19th-Postman]]></title>
    <url>%2F2019%2F05%2F01%2F%E6%B5%99%E6%B1%9F%E7%9C%81%E8%B5%9B19th-Postman%2F</url>
    <content type="text"><![CDATA[题目网址：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=4096 思路首先将坐标分组排序，两边分别计算路径最后相加，比较左边和右边离原点最远的点，这个点就只走一次（最后一次），然后从最远的点开始往原点“跳”，每次跳k个点直到回到原点（如此能保证总路径是最短的） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// Created by yunqi on 19-4-14.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;bool cmp(const long long a, const long long b) &#123; return a &lt; b;&#125;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n,k; vector&lt;long long&gt; left, right; long long ans = 0, a; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;a); if (a &gt;= 0) right.push_back(a); else left.push_back(abs(a)); &#125; int n1 = left.size(), n2 = right.size(); sort(left.begin(), left.end(), cmp); sort(right.begin(), right.end(), cmp); for (int i = n1 - k - 1; i &gt;= 0; i -= k) ans += (left[i] * 2); for (int i = n2 - k - 1; i &gt;= 0; i -= k) ans += (right[i] * 2); if (n1 &gt; 0 &amp;&amp; n2 &gt; 0) &#123; ans += (left[n1 - 1] * (left[n1 - 1] &gt;= right[n2 - 1] ? 1 : 2)); ans += (right[n2 - 1] * (left[n1 - 1] &gt;= right[n2 - 1] ? 2 : 1)); &#125; else if (n1 == 0) &#123; ans += right[n2 - 1]; &#125; else &#123; ans += left[n1 - 1]; &#125; printf("%lld\n", ans); &#125; return 0;&#125; 做题感受啊…..这道题的hint真的是让人入坑啊……先开始一直纠结，就是wa，后来杰霸来了向他求助，他说不就是一道傻逼题吗……（啊…当时真是抓狂orz，然后我就自己再改了一下，结果一直segmentfault,回南湖后再思考了一下发现left或right的元素个数可能为0，需要分类判断一下。还有个坑是今天重写了一遍，发现遍历vector时下标类型声明为unsignedlong（clion一直标黄提醒）就会t，声明为int就过了（暂时不知道咋回事……]]></content>
      <categories>
        <category>浙江省赛</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>浙江省赛</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些碎碎念]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[之前去长白山的时候，我就说我发现自己一年过去了还是没有什么进步，cf分数还是那么低，每次都做不到四道题，每次都要思考很久，简单的思路不会，暴力有时候还会卡壳，算法的应用烂得跟个啥一样。没有进步，我觉得这个状态很可怕。数学系的课程我学不懂，我也没有精力把所有的时间都放在上面，想保研太难了（当然也许是我持有借口一说，但我不想深入）。自己搞ACM，不，我觉得不是在搞，而是不上心地散一点时间在上面。诚然我付出的很少，特别是上学期，人嘛，没有自控力地生活总是会陷入烂泥里。所以我在长白山回来之后就问了zj学长，很丢人地自己状态说出来。是啊，云淇并不是很优秀。扪心自问，我付出得很少，特别是自从大一那事之后，我的状态就变得很奇怪。我不想以这个为借口，就事论事。但是很丢人啊，开学以来无论是月赛，天梯赛都是这样，做不好，做不快，做不对。我应该早点发觉，而不是一味地陷入那个烂泥里不出来。看柳婼的博客，能感觉她的确是一个优秀努力的人，而与我对比，自然分的高下，这种比对之后的差别是很可耻的，就像昨天填的表格一样，很丢人。不能因为我不是计算机的学生就给自己找借口，我应该找到合适的状态，把自己放的很谦卑，把自己放在泥地里，只有抬头才能向上，而不是心悬在空中向下俯视。我想变强，怎么去付诸，怎么去调整，怎么去改变心态，怎么去不丢人。昨天晚上真的很想让世界上所有的人都忘记我，很丢人很丢人，简直想去死。我很好面子，很要强，对我来说是挺打击的。可是万事有因有果，这是一场马拉松，中间的懈力已经很明显了。不想成为现在的样子，很差劲，没有力气去调整人际关系，和小泽也不想说话了，也知道我性格的弊病已经显现出来了，我明白，可是我不想说出来，因为我总是忍不住发脾气。需要找到一个情感的宣泄口，比赛又会自虐，或许负面情绪会更多，但是还是要去试试的。上面的话很没有逻辑，我的手指已经被机械键盘打疼了，应该让自己理智一点。更多的话，以后再说吧。哦，今天还想剪头，昨天大姨妈来了常微分课上疼的要死要活，打瞌睡都睡不了。昨晚又在科学馆待了一晚上，效率不是很好，还困，又不敢发出声音怕被发现，然后还有这烦死人的大姨妈。啊，要活下去，坚强地活下去。 2019年4月18日17:28]]></content>
      <categories>
        <category>没有目录</category>
      </categories>
      <tags>
        <tag>没有tag</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEUOJ-2019-1Monthly-6]]></title>
    <url>%2F2019%2F04%2F18%2FNEUOJ-2019-1Monthly-6%2F</url>
    <content type="text"><![CDATA[Problem Description给你一个n个数的序列 已知这n个数为1,1/2,1/3….1/n 我们定义一个生成新序列的操作mjfgay: 每次将序列相邻两项相加并且取平均。并将新生成的序列代替原来的序列。 比如 对于序列 1 1/2 1/3 ，经过一次mjfgay操作后，我们可以得到一个新序列 3/4 5/12 显然，经过n-1次之后，这个序列只会剩一个数 每次给你序列的长度n，问经过n-1次mjfgay操作过后，剩下的数是多少 答案对1e9+7取模 即若答案为P/Q，输出的是P*(Q^(-1))%(1e9+7) Q^(-1)代表逆元Input第一行输入一个整数t，代表数据组数(1&lt;=t&lt;=1000000) 每组数据输入一个正整数n，代表题目中的n (2&lt;=n&lt;2^26) Output对每组数据 输出答案%1e9+7的值 Sample Input223 Sample Output750000006583333338 思路找规律。杰霸写的题解看不懂=_=，但我推出了结果的式子（纯暴力推出），最后的P是2^n-1,Q是n(2^(n-1)),因为Q可能很大，会爆精度，所以变除法为乘法，下面讲一下逆元。设c是b的逆元，则有bc三1(mod m)(同余)则(a/b)%m=(a/b)1%m=(a/b)bc%m=ac%m即a/b的模等于a*b的逆元的模如何求逆元呢？需要用到费马小定理。如果b与m互质，那么就有b^(m-1)三1(mod m)这个式子和前面的逆元关系式连接起来，得到c=b^(m-2)，快速幂求结果即可，复杂度O(logn) 代码1234567891011121314151617181920212223242526272829303132333435363738394041//// Created by Yunqi on 19-4-18 上午12:37.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define mod 1000000007using namespace std;typedef long long ll;ll qpower(ll n, ll m) &#123; if (n == 1) return 1LL; ll ret = 1; while (m &gt; 0) &#123; if (m &amp; 1) ret = (ret * n) % mod; n = (n * n) % mod; m &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; int t; while (cin &gt;&gt; t) &#123; while (t--) &#123; long long n; cin &gt;&gt; n; ll com = qpower(2LL, n - 1); ll nume = com * 2 - 1; ll deno = n * com % mod; ll niyuan = qpower(deno, mod - 2); ll ans = nume * niyuan % mod; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 做题感受啊….四个月之后的我还是推不出式子，比赛完之后好像推出来了，所以ac了，现在推还是很傻比地往杨辉三角靠（虽然好像是这个关系），然后又去查杨辉三角的式子，得到是C(n-1,m-1),然后又去算阶乘，算每一步的逆元，算最小公倍数分式加和（我在想什么……以上充分证明了我对数字关系很不敏感，就和上一道负进制一样，哎，多锻炼思维吧。附上逆元的博客：【逆元】]]></content>
      <categories>
        <category>NEUOJ</category>
        <category>逆元</category>
      </categories>
      <tags>
        <tag>NEUOJ</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NEUOJ-2018新生赛-2]]></title>
    <url>%2F2019%2F04%2F18%2FNEUOJ-2018%E6%96%B0%E7%94%9F%E8%B5%9B-2%2F</url>
    <content type="text"><![CDATA[思路我们习惯将10进制转换为正进制，方法无非是取余n，其商再继续取余直至该数被除至0，依次得到的余数倒序即为该十进制的n进制表示。如果是-n进制，方法也基本一样，永远满足被除数=商除数+余数，这里注意余数&gt;=0，当余数是负数时，将商++之后把余数变为正数（-=进制n）举个栗子：-1 = 1 (-2)^1 + 1 (-2)^0;① -1%（-2）=-1，-1/-2=0 ——&gt; -1-（-2）=1,0+1=1 ——&gt; 0（-2）-1=1*（-2）+1② 1%（-2）=1,1/（-2）=0-1用二进制表示就是11 代码12345678910111213141516171819202122232425262728293031323334353637//// Created by Yunqi on 19-4-17 下午9:55.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;vector&lt;long long&gt; ans;int main() &#123; long long n; while (cin &gt;&gt; n) &#123; ans.clear(); if (n == 0) &#123; cout &lt;&lt; n &lt;&lt; endl; continue; &#125; while (n != 0) &#123; long long com1 = n % (-2); long long com2 = n / (-2); if (com1 &lt; 0) &#123; com1 += 2; ++com2; &#125; ans.push_back(com1); n = com2; &#125; for (int i = (int)ans.size() - 1; i &gt;= 0; --i) printf("%lld", ans[i]); cout&lt;&lt;endl; &#125; return 0;&#125; 做题感受这道题一直做不出来囧，手推了好久也没推出来，自闭到绝望，后来搜了一下负进制，百度百科直接给出了代码，比赛完之后试了一下就过了=_=。然后昨天再次尝试做，还是没推出来（说明写过的题还是特么的不会），推的这个过程很自闭。然后遇到的一个问题是最后遍历vector输出的时候，下标i如果声明为unsigned long类型就会输出一堆多余的东西，如果声明为int类型就不会，不知道怎么回事orz（这个坑先不填附上负进制的博客: 负进制的转换]]></content>
      <categories>
        <category>算法</category>
        <category>负进制</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>NEUOJ</tag>
        <tag>负进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-1.4-Dual_Palindromes]]></title>
    <url>%2F2019%2F04%2F18%2FUSACO-1-4-Dual-Palindromes%2F</url>
    <content type="text"><![CDATA[思路和1.3思路一样，这一次只是多增加了判断是否有两个以上的进制表示是回文数字 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* ID: cm291182 TASK: dualpal LANG: C++*///// Created by Yunqi on 19-4-17 下午3:49.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;fstream&gt;#include&lt;cstdio&gt;using namespace std;bool judge(int base, int n) &#123; int num[1000], tot = 0; while (n != 0) &#123; num[++tot] = n % base; n /= base; &#125; for (int i = 1, j = tot; i &lt;= j; ++i, --j) &#123; if (num[i] != num[j]) return false; &#125; return true;&#125;int main() &#123; ifstream fin("dualpal.in"); ofstream fout("dualpal.out"); int n, s; while (fin &gt;&gt; n &gt;&gt; s) &#123; int cnt = 0; for (int i = s + 1; cnt &lt; n; ++i) &#123; int tot = 0; for (int j = 2; j &lt;= 10; ++j) &#123; if (judge(j, i)) &#123; ++tot; if (tot == 2) &#123; ++cnt; fout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 做题感受没啥感受，一开始判断没写对，然后还好。其实每次做到进制的题都觉得不好写，可能觉得进制方面的知识太深了，题见多了就行。]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>USACO</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO-1.3-Palindromic_Squares]]></title>
    <url>%2F2019%2F04%2F18%2FUSACO-1-3-Palindromic-Squares%2F</url>
    <content type="text"><![CDATA[思路N范围在【1,300】，暴搜一遍，借用一个数组存转换进制之后的digit，然后短除法取模即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*ID: cm291182TASK: palsquareLANG: C++*/#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;fstream&gt;using namespace std;char base[20] = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'&#125;;int main(void) &#123; ofstream fout("palsquare.out"); ifstream fin("palsquare.in"); int b; while (fin &gt;&gt; b) &#123; for (int i = 1; i &lt;= 300; ++i) &#123; string ans1, ans2; int squ = i * i, com = i; while (com &gt; 0) &#123; ans1 += base[com % b]; com /= b; &#125; reverse(ans1.begin(), ans1.end()); while (squ &gt; 0) &#123; ans2 += base[squ % b]; squ /= b; &#125; bool flag = true; string::iterator j,k; for (j = ans2.begin(), k = ans2.end() - 1; j &lt;= k; ++j, --k) &#123; if (*j != *k) &#123; flag = false; break; &#125; &#125; if (flag) fout &lt;&lt; ans1 &lt;&lt; " " &lt;&lt; ans2 &lt;&lt; endl; &#125; &#125; return 0;&#125; 做题感受一年前的我做这道题觉得很难，所以之后就没做了，现在看来不是很难。中间遇到的坑是短除法取模得到的数字顺序与输出顺序是相反的=_=，借用reverse一波，然后就是字符串的问题，开始把ans1和ans2的声明放在循环外面，这样会导致字符串会保留上一次的结果。哦，最初也没看到要输出n表示为b进制后的数字，直接输出十进制的n了。]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>USACO</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2050热身赛（赶火车）【数学期望】]]></title>
    <url>%2F2019%2F04%2F11%2F2050%E7%83%AD%E8%BA%AB%E8%B5%9B%EF%BC%88%E8%B5%B6%E7%81%AB%E8%BD%A6%EF%BC%89%E3%80%90%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%E3%80%91%2F</url>
    <content type="text"><![CDATA[思路期望就是走这条路的概率*这条路到达的时间，设期望为Ex，则Ex=(a1+a2+…+an+(b1+Ex)+(b2+Ex)+…+(bm+Ex))/(n+m)，化简一下就是Ex=(a1+a2+…+an+b1+b2+…+bm)/n.式子的意思为，如果走可以到达终点的n条路的话，选取的概率就是1/(n+m)，所花时间就是ai，如果走其他的m条路的话，选取的概率是1/(n+m),所花时间就是bi+Ex.期望值一个近似平均值，当我们走那m条路时，走了bi时间后又回到原点，这时候跟最开始的情况又一样了，而我们已经设期望时间是Ex了，所以总共时间就是bi+Ex（自己好好思索一下） 代码123456789101112131415161718192021222324252627282930313233//// Created by yunqi on 19-4-11.//#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int main(void) &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, m; double y; scanf("%d%d%lf", &amp;n, &amp;m, &amp;y); double a, sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lf", &amp;a); sum += a; &#125; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%lf", &amp;a); sum += a; &#125; double ans = sum / n; if (ans &gt; y) printf("Wait\n"); else printf("Go\n"); &#125; return 0;&#125; 做题感受啊……看到这道题我就知道寒假训练时有一道题和这道很像，而我又忘记是怎么做的了（囧），所以又去翻代码，发现还不是很懂又直接去搜了题解orz啊……这次写了题解自己大概有一点认识吧（底气不足]]></content>
      <categories>
        <category>算法</category>
        <category>数学期望</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-特立独行的幸福数（2019年决赛）]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E5%B9%B8%E7%A6%8F%E6%95%B0%EF%BC%882019%E5%B9%B4%E5%86%B3%E8%B5%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思路幸福数求法是如果不是幸福数，那么一定会出现循环，一种方法是标记每次得到的数，另一种骚操作是判断20是否会出现（如果出现20，那么这个数就一定不是幸福数（小明某一次打表找到的规律而这道题还要判断是不是独立的，那么开个vector记录每次得到的数的前一个数，同时也记录每个幸福数要得到1需要经过几次转换，最后再判断是不是质数即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//// Created by yunqi on 19-4-5.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e4 + 10;int relate_num[maxn];vector&lt;int&gt; pre_num[maxn];vector&lt;int&gt; num;int prime[maxn];bool vis[maxn];int cnt = 0;void get_prime() &#123; for (int i = 2; i &lt;= maxn; i++) &#123; if (!vis[i]) prime[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= maxn; j++) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125;bool judge(int n) &#123; int nn = n; int ret = 0; while (true) &#123; int com = nn; while (nn != 0) &#123; ret += (nn % 10) * (nn % 10); nn /= 10; &#125; relate_num[n]++; if (ret == 1) return true; else if (ret == 4 || ret == 20 || ret == 16) return false; pre_num[ret].push_back(com); nn = ret; ret = 0; &#125;&#125;void init() &#123; for (int i = 1; i &lt;= maxn; i++) if (judge(i)) num.push_back(i);&#125;int main() &#123; int a, b; get_prime(); init(); while (~scanf("%d%d", &amp;a, &amp;b)) &#123; int _size = (int) num.size(); bool flag1=false; for (int i = 0; i &lt; _size; i++) &#123; if (num[i] &gt; b) break; if (num[i] &gt;= a &amp;&amp; num[i] &lt;= b) &#123; bool flag = true; for (int j = 0; j &lt; pre_num[num[i]].size() &amp;&amp; flag; j++) if (pre_num[num[i]][j] &gt;= a &amp;&amp; pre_num[num[i]][j] &lt;= b) flag = false; if (flag) &#123; printf("%d %d\n", num[i], relate_num[num[i]] * (vis[num[i]] ? 1 : 2)); flag1 = true; &#125; &#125; &#125; if(!flag1) printf("SAD\n"); &#125; return 0;&#125; 做题感受比赛的时候，啊……一直在卡，赛后发现自己题意理解错了，同时自己赛后补题的过程中发现你需要把这个数a的所有前一个数bi都判断一下是否在区间内，其实整体写下来也不难，哎自己太菜了]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-深入虎穴（2019年决赛）]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E6%B7%B1%E5%85%A5%E8%99%8E%E7%A9%B4%EF%BC%882019%E5%B9%B4%E5%86%B3%E8%B5%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思路这是一棵树，但要把无根变为有根，题目中“只有一个出口”的条件便能确定这个树的根，由根去dfs就行了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// Created by yunqi on 19-4-3.//#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5 + 10;vector&lt;int&gt; num[maxn];bool judge[maxn];int maxdep, maxid;void dfs(int pos, int depth) &#123; if (num[pos].empty()) &#123; if (maxdep &lt; depth) &#123; maxdep = depth; maxid = pos; &#125; return; &#125; else &#123; for(int i = 0; i &lt; num[pos].size(); i++) dfs(num[pos][i],depth+1); return; &#125;&#125;int main(void) &#123; int n; while (~scanf("%d", &amp;n)) &#123; int k, a; memset(judge, false, sizeof(judge)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;k); for (int j = 1; j &lt;= k; j++) &#123; scanf("%d", &amp;a); num[i].push_back(a); judge[a] = true; &#125; &#125; maxdep = 0; for (int i = 1; i &lt;= n; i++) if (!judge[i]) dfs(i, 1); printf("%d\n",maxid); &#125; return 0;&#125; 做题感受啊啊比赛的时候没有仔细去看只有一个入口这个条件，想当然以为有多个入口，所以用了最暴力的dfs去做（当然超时了，最后只拿了19分，哎关于dfs树这种题其实在之前就已经做过好几道了，比如小字辈、愿天下有情人都是兄妹哎，这一次打得真的差]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-分而冶之]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%88%86%E8%80%8C%E5%86%B6%E4%B9%8B%2F</url>
    <content type="text"><![CDATA[思路这道题也不难，不用想到什么无向图连通判断，只要对攻下的城市做记录，在跑一遍所有的边，看是否有一条边两个点都没被记录，这样的边就是孤立边给的时间是600ms，k是100,m是10000，复杂度就是km，完全不会超时（要学会对复杂度的预判呐 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e4+10;struct Edge&#123; int u,v;&#125;edge[maxn];bool mark[maxn];int main(void)&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;edge[i].u,&amp;edge[i].v); int k,num,node; scanf("%d",&amp;k); while(k--)&#123; bool flag=true; memset(mark,false,sizeof(mark)); scanf("%d",&amp;num); for(int i=1;i&lt;=num;i++) &#123; scanf("%d", &amp;node); mark[node] = true; &#125; for(int i=1;i&lt;=m;i++)&#123; if(!mark[edge[i].u]&amp;&amp;!mark[edge[i].v])&#123; flag=false; break; &#125; &#125; if(!flag) printf("NO\n"); else printf("YES\n"); &#125; &#125; return 0;&#125; 做题感受想复杂了，以为是无向图连通判断，发现自己不熟，就放弃这道题了]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-红色警报]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BA%A2%E8%89%B2%E8%AD%A6%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[思路第一种方法就是暴力，图我发现自己惯用vector来存，其实邻接矩阵也行，然后习惯用广搜，不习惯用深搜。比赛的时候想的巨复杂，其实还是因为自己做题太少，我居然想到用判断每个点所在连通块是否不连通来做（这也是我为什么想不到好的算法的原因吧，做题少脑子又木。用广搜算出连通块数量即可，也是很暴力的那种（似乎我现在对于暴力做很害怕？，注意的是攻占城市是一个一个攻占，已经被攻占的城市不涉及其他城市连通性，所以每次的基准连通量数目都要改（我没有想到这一点，所以才疯狂wa吧。用并查集来做也可以，不过也是偏向暴力的那种，每一次判断都要重新做一次并查集，基准连通数目每一次也要变，并查集通过计算根节点的数目得到连通块数目。注意的是连通块数目增１和不变都是不改变连通性的（被攻占的城市已经算一个连通块了 代码给出两种，一种深搜暴力，一种并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000;vector&lt;int&gt; G[maxn];int n,m,k,node[maxn];int arr[maxn][maxn];bool vis[maxn];queue&lt;int&gt; q;void bfs()&#123; while(!q.empty())&#123; int p=q.front(); q.pop(); vis[p]=true; for(int i=0;i&lt;G[p].size();i++)&#123; if(!vis[G[p][i]])&#123; q.push(G[p][i]); vis[G[p][i]]=true; &#125; &#125; &#125;&#125;int main(void)&#123; scanf("%d%d",&amp;n,&amp;m); int a,b,cnt=0; memset(arr,0,sizeof(arr)); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;a,&amp;b); if(!arr[a][b]&amp;&amp;!arr[b][a]) &#123; G[a].push_back(b); G[b].push_back(a); &#125; arr[a][b]=1; arr[b][a]=1; &#125; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;n;i++)&#123; if(!vis[i])&#123; cnt++; q.push(i); bfs(); &#125; &#125; scanf("%d",&amp;k); for(int j=1;j&lt;=k;j++)&#123; memset(vis,false,sizeof(vis)); for(int l=1;l&lt;=j-1;l++) vis[node[l]]=true; scanf("%d",&amp;node[j]); vis[node[j]]=true; int com=0; for(int i=0;i&lt;n;i++)&#123; if(!vis[i])&#123; com++; q.push(i); bfs(); &#125; &#125; if(com&gt;cnt) printf("Red Alert: City %d is lost!\n",node[j]); else printf("City %d is lost.\n",node[j]); if(j==n) printf("Game Over.\n"); cnt=com; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1000;int far[maxn];int n,m,k;bool vis[maxn];struct Edge&#123; int x,y;&#125;edge[maxn*5+10];void init()&#123; for(int i=0;i&lt;n;i++)&#123; vis[i]=false; far[i]=i; &#125;&#125;int find(int x)&#123; if(far[x]==x) return far[x]; else return far[x]=find(far[x]);&#125;void Union(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) far[x]=y;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;edge[i].x,&amp;edge[i].y); Union(edge[i].x,edge[i].y); &#125; int cnt=0,com,node; for(int i=0;i&lt;n;i++) if(far[i]==i) cnt++; scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++)&#123; com=0; scanf("%d",&amp;node); vis[node]=true; for(int j=0;j&lt;n;j++) far[j]=j; for(int j=1;j&lt;=m;j++) if(!vis[edge[j].x]&amp;&amp;!vis[edge[j].y]) Union(edge[j].x,edge[j].y); for(int j=0;j&lt;n;j++) if(far[j]==j) com++; if(com&gt;cnt+1) printf("Red Alert: City %d is lost!\n",node); else printf("City %d is lost.\n",node); if(i==n) printf("Game Over.\n"); cnt=com; &#125; &#125; return 0;&#125; 做题感受训练时真的心态崩了啊，一直在卡这道题，结束前只过了一个样例，后来又发现自己写蠢了一个地方，最后半个小时自己完全就是木的吧（你看这心态就不好打完吃饭的时候搜题解，才发现题意也理解错了，想的方法也巨他妈复杂。]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-猜数字]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%8C%9C%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[思路猜数字：其实非常简单，但是就是不知道为啥我没做对，这一次是用的map，比赛用的是结构体，真是绝了。map的lower_bound方法是找出第一个大于等于key的迭代器指针 代码12345678910111213141516171819202122232425262728293031#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;map&lt;int,string&gt; name;int main(void)&#123; int n; while(~scanf("%d",&amp;n))&#123; int num,ans; string s; double sum=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s&gt;&gt;num; name[num]=s; sum+=num; &#125; sum/=(2*n); map&lt;int,string&gt;::iterator it,it1; it=name.lower_bound((int)sum); it1=it; ans=it-&gt;first; if(sum-it-&gt;first&gt;(it1++)-&gt;first-sum) ans=(it++)-&gt;first; cout&lt;&lt;(int)sum&lt;&lt;" "&lt;&lt;name[ans]&lt;&lt;endl; &#125; return 0;&#125; 做题感受感觉很谜，为啥比赛时没过，我只是把结构体换成map而已。pintia只能看到两页的提交记录，也试验不了了，如果又是和小字辈一样的话，我真是要吐血orx]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-是否完全二叉搜索树]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思路二叉树的判断，如果是完全，则深度为h的树，除了第h层，其它层都是满的，这里用结构体来存二叉树，同时判断是否为完全。二叉树的空间定义为1&lt;&lt;20，其实用到的最大空间为1&lt;&lt;20-1，父节点为i，子节点就为i&lt;&lt;1,i&lt;&lt;1+1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define INF 0x3f3f3f3fusing namespace std;const int maxn=1&lt;&lt;20+1;int node[maxn],a;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; for(int i=1;i&lt;=maxn;i++) node[i]=INF; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a); for(int j=1;j&lt;=maxn;)&#123; if(node[j]==INF)&#123; node[j]=a; break; &#125;else&#123; if(node[j]&lt;a) j&lt;&lt;=1; else j&lt;&lt;=1,j+=1; &#125; &#125; &#125; bool flag=true; int cnt=0; for(int i=1;i&lt;=maxn;i++)&#123; if(node[i]==INF) flag=false; if(node[i]!=INF)&#123; cnt++; printf("%d%c",node[i],cnt==n?'\n':' '); if(cnt==n) break; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 做题感受比赛没有看这道题，在纠结前面的红色警报，但是才发现自己对二叉树的理解很差劲，就算看了也不一定会吧（所以说自己很差劲,勉励吧:(]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-愿天下有情人都是兄妹]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E6%84%BF%E5%A4%A9%E4%B8%8B%E6%9C%89%E6%83%85%E4%BA%BA%E9%83%BD%E6%98%AF%E5%85%84%E5%A6%B9%2F</url>
    <content type="text"><![CDATA[思路就是深搜（也是最直接的思路）,结构体存每个人的性别，父母id，如果父母id是-1，就记为0（没有人的id是00000），先搜第一个人的祖先，最多搜到第五代就停止，将搜到的id做标记，然后搜第二个人的祖先，如果在第五代之内有第一个人的祖先，那么就输出no这道题和小字辈很相似，都是深搜的题。我遇到了两个坑点，一个是每个人的父母也要标明性别，另一个是输入id，性别的时候，如果是用cin连续输入的话，有三个样例点就过不了，如果第一个id和性别分开输入的话，就可以过了（搜了很多关于cin的资料，但还是不明白，留给以后的自己填坑。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;const int maxn=int(1e5+10);struct Node&#123; char gender; int far; int mom;&#125;node[maxn];bool vis[maxn];bool ans;void dfs(int x,int ok,int depth)&#123; if(depth&gt;5||!ans||x==0) return ; if(ok==1&amp;&amp;vis[x])&#123; ans=false; return ; &#125; vis[x]=true; dfs(node[x].far,ok,depth+1); dfs(node[x].mom,ok,depth+1);&#125;int main()&#123; int n; while(cin&gt;&gt;n)&#123; int id,fid,mid; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;id; cin&gt;&gt;node[id].gender&gt;&gt;fid&gt;&gt;mid; fid=fid==-1?0:fid; mid=mid==-1?0:mid; node[id].far=fid; node[id].mom=mid; node[fid].gender='M'; node[mid].gender='F'; &#125; int k,a,b; cin&gt;&gt;k; while(k--)&#123; memset(vis,false,sizeof(vis)); ans=true; cin&gt;&gt;a&gt;&gt;b; if(node[a].gender==node[b].gender) printf("Never Mind\n"); else&#123; dfs(a,0,1); dfs(b,1,1); if(ans) printf("Yes\n"); else printf("No\n"); &#125; &#125; &#125; return 0;&#125; 做题感受比赛时纠结红色警报那道题了，这道题根本没看，不过私底下补题的时候还是遇到了坑点，估计比赛时做也没办法拿满分吧（还需努力啊。还有，一开始以为编号必须用字符串存，后来试了一下直接当int输入也可以。]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛-小字辈]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E5%B0%8F%E5%AD%97%E8%BE%88%2F</url>
    <content type="text"><![CDATA[思路一道深搜题，不过要注意记忆化搜索，用maxx记录最小的那一辈(rank值最大），然后用vector存每一辈的下标，因为是顺序存的，所以输出也是递增的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=1e5+10;int _rank[maxn];int far[maxn];int getrank(int i)&#123; if(_rank[i]!=0) return _rank[i]; else return _rank[i]=getrank(far[i])+1;&#125;int main(void)&#123; int n; while(~scanf("%d",&amp;n))&#123; vector&lt;int&gt; ans[maxn]; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;far[i]); if(far[i]==-1) _rank[i]=1; else _rank[i]=0; &#125; int maxx=-1; for(int i=1;i&lt;=n;i++)&#123; getrank(i); maxx=max(maxx,_rank[i]); ans[_rank[i]].push_back(i); &#125; unsigned long _size=ans[maxx].size(); printf("%d\n",maxx); for(unsigned long i=0;i&lt;_size;i++) printf("%d%c",ans[maxx][i],i==_size-1?'\n':' '); &#125; return 0;&#125; 做题感受一开始我是没有用上面的代码实现深搜，就是dfs记录了搜索深度，每搜一次深度加1，现在想想并不是很好，很容易超时。上面的代码开了rank数组来记录，只要rank的值已经求出来了就立刻返回，记忆化搜索很妙啊:)然后关于按顺序输出，我也是东想西想，甚至还想开个map……(我在想什么……，不用上面代码vector实现，开个结构体排序处理一下也好嘛……(我x*&amp;.#$@….哦还不止如此，我调了很久最后发现不用多组输入就过，用就会wa一个样例点，但是我很认真的检查了关于初始化没有问题啊，当时真的是……绝了，然而我刚刚又交了之前貌似没过的代码，结果就过了，我:??????我一定是见到了异世界（或者我见到了平行世界的我见到的场景？？？（我在说什么……更新刚刚实时测试了一下，把有一个样例点没过的代码复制粘贴再提交了一次，发现就过了……什么神奇的网站xxxxxxxx（真的是要吐血，浪费我很多很多很多很多很多时间去纠结一个实际上没有错的东西？？？？？？体验真是极差cao]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－名人堂与代金劵]]></title>
    <url>%2F2019%2F03%2F26%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%90%8D%E4%BA%BA%E5%A0%82%E4%B8%8E%E4%BB%A3%E9%87%91%E5%8A%B5%2F</url>
    <content type="text"><![CDATA[思路很简单很入门级的题，ACMer选手写这种题就是过家家，但是不知道最近我的脑袋是怎么了，这种题都会卡（卡nm?，这个脑子啊……，写个结构体然后排序不就好了嘛，充其量就是这个排名卡一下……哎，我居然在处理排名的时候又建了个数组然后非要用lower_bound来找分数一样的人有多少个然后在输出==，感觉我是被lower_boung带入歧途其实很简单的，用个com记录上一个排名，然后和当前的比较，如果分数一样，com不变，否则就更新为i，最后要注意当com&gt;k的时候才结束，不是输出k个就结束 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;const int maxn=1e4+10;struct Node&#123; string id; int score;&#125;stu[maxn];bool cmp(const Node&amp; a,const Node&amp; b)&#123; if(a.score&gt;b.score) return true; else if(a.score==b.score) return a.id&lt;b.id; else return false;&#125;int main(void)&#123; int n,g,k; while(~scanf("%d%d%d",&amp;n,&amp;g,&amp;k))&#123; int sum=0; for(int i=1;i&lt;=n;i++) &#123; cin &gt;&gt; stu[i].id &gt;&gt; stu[i].score; if (stu[i].score &gt;= g) sum += 50; else if (stu[i].score &gt;= 60 &amp;&amp; stu[i].score &lt; g) sum += 20; &#125; sort(stu+1,stu+n+1,cmp); int com=1; printf("%d\n",sum); for(int i=1;com&lt;=k;)&#123; cout&lt;&lt;com&lt;&lt;" "&lt;&lt;stu[i].id&lt;&lt;" "&lt;&lt;stu[i].score&lt;&lt;endl; if(stu[++i].score!=stu[com].score) com=i; &#125; &#125; return 0;&#125; 做题感受没啥感受，就是愈发觉得自己变蠢了]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－列车调度]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%88%97%E8%BD%A6%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[思路这道题就是求递减子列的个数，我的方法是开一个数组来记录当前每个递减子列的尾值，如果要插入的这个数大于所有尾值中最大的那一个，那么ans就+1，这个数就是新的递减子列的头(同时也是这个递减子列的尾，因为此时子列只有它一个元素)，反之，用lower_bound找到最小的大于这个数的尾值，这个数就变为该递减子列的尾(更新尾值)。因为尾值数组始终保持递增(有序),所以可以用lower_bound来找。 代码12345678910111213141516171819202122232425262728#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e5+10;int a,b[maxn];int main(void)&#123; int n; while(cin&gt;&gt;n)&#123; int maxx=0,cnt=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a); if(a&gt;maxx)&#123; maxx=a; b[++cnt]=a; &#125;else&#123; unsigned long k=lower_bound(b+1,b+cnt+1,a)-b; b[k]=a; if(k==cnt) maxx=a; &#125; &#125; printf("%d\n",cnt); &#125; return 0;&#125; 做题感受比赛时没有拿满分，有一个样例点没过，是因为我把数字插入顺序想反了，虽然也能做，但是也更复杂，后来补题的时候忘了如果数组中没有找到大于特定值的时候lower_bound会返回什么，所以自己用了maxx来记录最大的尾值，然后之后又忘记如果k=cnt的话时maxx也要更新==，逻辑真是硬伤啊orz（就是上面的代码。如果要按照思路来写的话，删掉maxx,如果k=cnt+1的话，那么就b[++cnt]=a]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－关于堆的判断]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%85%B3%E4%BA%8E%E5%A0%86%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[思路堆(Heap)的概念清楚了这道题就不难，按照插入顺序建堆理解起来也不难，用map判断比较快。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;const int maxn=1010;map&lt;int,int&gt; num;int a[maxn];string str;int x,y;void print(bool ans)&#123; if(ans) cout&lt;&lt;"T"&lt;&lt;endl; else cout&lt;&lt;"F"&lt;&lt;endl;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m)&#123; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); int j=i; while(j!=1)&#123; if(a[j]&lt;a[j/2]) swap(a[j],a[j/2]); j/=2; &#125; &#125; num.clear(); for(int i=1;i&lt;=n;i++) num[a[i]]=i; while(m--)&#123; bool ans=true; cin&gt;&gt;x; cin&gt;&gt;str; if(str=="and")&#123; cin&gt;&gt;y&gt;&gt;str&gt;&gt;str; if(num[x]/2!=num[y]/2) ans=false; print(ans); continue; &#125; cin&gt;&gt;str; if(str=="a")&#123; cin&gt;&gt;str&gt;&gt;str&gt;&gt;y; if(num[x]/2!=num[y]) ans=false; print(ans); continue; &#125; cin&gt;&gt;str; if(str=="root")&#123; if(num[x]!=1) ans=false; print(ans); continue; &#125; cin&gt;&gt;str&gt;&gt;y; if(num[y]/2!=num[x]) ans=false; print(ans); &#125; &#125; return 0;&#125; 做题感受咳咳，基础知识不牢固啊，堆的概念不清楚，并且一开始只想到先输入一行字符串，然后遍历判断是哪种情况，同时获取x和y的值，后来看到一篇博客分隔输入判断，实在是妙啊。不过这种方法的坑点是，无论你是否已经判断为哪种情况，你都需要把剩下的字符串全部输入完(否则输入缓存区还留有未处理的字符串，对下一次的输入造成影响)]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天梯赛－倒数第N个字符串]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%A4%A9%E6%A2%AF%E8%B5%9B%EF%BC%8D%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[思路脑子头脑风暴一下，或者手推，就会发现这道题可以转换为26进制来做（0为a,25为z），倒数第１个字符串是zzz，即zzz-aaa，倒数第二个字符串是zzy，即zzz-aab，倒数第26个字符串是zza，即zzz-aaz,即把n-1转换为26进制，然后用zzz相减即可 代码123456789101112131415161718192021222324252627#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int ans[10];int main(void) &#123; int l, n; while(~scanf("%d%d",&amp;l,&amp;n))&#123; int com[10], tnt = 0; n--; while (n != 0) &#123; com[++tnt] = n % 26; n /= 26; &#125; for (int i = 1; i &lt;= l; i++) ans[i] = 122; for (int i = l - tnt + 1, j = tnt; j &gt;= 1; i++, j--) ans[i] = 122 - com[j] ; for (int i = 1; i &lt;= l; i++) printf("%c", ans[i]); printf("\n"); &#125; return 0;&#125; 做题感受比赛时真的想了好久，哎，脑子是木的，有抓住一点26进制的影子（其实单纯的想到字母的相差关系也行），先开始一直对n取余、相除，后来想到n-1，然后才过的。归根结底还是思路和逻辑不够，解决办法刷题呗。]]></content>
      <categories>
        <category>天梯赛题解</category>
      </categories>
      <tags>
        <tag>天梯赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[费马大定理＆＆费马小定理]]></title>
    <url>%2F2019%2F03%2F09%2F%E8%B4%B9%E9%A9%AC%E5%A4%A7%E5%AE%9A%E7%90%86%EF%BC%86%EF%BC%86%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数＆欧拉定理＆欧拉降幂]]></title>
    <url>%2F2019%2F03%2F09%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%EF%BC%86%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%EF%BC%86%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82%2F</url>
    <content type="text"><![CDATA[前言上一篇博客我们讲到了快速幂(一般&amp;&amp;矩阵)，现在我们要讲讲一个叫欧拉降幂的东西，为了得到欧拉降幂公式，我们需要回顾一下欧拉函数，再到欧拉定理以及拓展欧拉定理。 欧拉函数公式欧拉函数phi[x],表示[1,x-1]区间中与x互质的数的个数phi[x]=x(1-1/a1)(1-1/a2)…(1-1/an)，其中ai是x的质因数那么就可以得到欧拉函数的一个性质，若p是质数，那么phi[p]=p-1(这一条有时会用到)以及phi[ip]=pphii，phi[ip]=(p-1)*phii 怎么求我们可以用线性筛筛出所有的欧拉函数，首先用线性筛找出[1,n]之间所有的素数，然后根据公式算出欧拉函数值下面是线性筛代码 12345678910111213141516const int maxn = 1e5;int prime[maxn];bool vis[maxn];int tot = 0;void get_prime() &#123; for (int i = 2; i &lt;= maxn; i++) &#123; if (!vis[i]) prime[++tot] = i; for (int j = 1; i * prime[j] &lt;= maxn &amp;&amp; j &lt;= tot; j++) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125;&#125; 然后是求phi[x]的部分12345678910111213int get_phi(int n) &#123; //求n的欧拉函数值，即phi[n] int ret = n; for (int i = 1; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= n; i++) &#123; if (n % prime[i] == 0) &#123; ret *= (1 - 1 / prime[i]); while (n % prime[i] == 0) n /= prime[i]; &#125; &#125; if (n &gt; 1) ret *= (1 - 1 / n); return ret;&#125; 欧拉定理有了欧拉函数做坚实的后盾，讲欧拉定理就不需要扯那些乱七八糟的东西了(好吧其实是我不会证“整那些干啥，会用就行了。”————鲁迅先扔一个公式，当a,n互质时，a^(phi[n])%n=1，这个公式可以推出a^(phi[n])与n互质(不是废话…似乎不是很直观的样子，那么再换一个a^b(mod n)=a^(b%phi[n])(mod n)(这大概是最有用的公式证明也比较简单，把b表示为phi[n]的一次多项式，即b=x*phi[n]+y，因为有a^(phi[n])%n=1,所以a^b(mod n)=a^y(mod n)=a^(b%phi[n])(mod n)ps:这个公式可以用于欧拉降幂（后面会将 拓展欧拉定理接下来咱们再整个拓展欧拉定理，嗯，拓展大多数情况下不都是从特殊情况推广到一般情况嘛，那咱再整个a,n不互质时有什么样的公式当b&lt;phi[n]时，a^b(mod n)=a^b(mod n);当b&gt;=phi[n]时，a^b(mod n)=a^(b%phi[n]+phi[n])(mod n)证明？不存在的，我还要头发呢！“整那些干啥，会用就行了。” ————鲁迅 欧拉降幂很庆幸，你不用再新推什么奇怪的公式，其实欧拉降幂公式就是欧拉定理和拓展欧拉定理结合起来关于欧拉降幂的应用场景，对于一个问题求a^b(mod n)根据条件把式子转换为三个中的一个好yeah降幂成功惹代码也不给了因为比较简单（不就是求欧拉函数再结合一下快速幂嘛 友情连接：欧拉函数&amp;欧拉定理&amp;降幂 总结(这个网站的mathjax支持好好啊，next自带的辣鸡]]></content>
      <categories>
        <category>算法</category>
        <category>欧拉函数</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂（一般＆＆矩阵）]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%88%E4%B8%80%E8%88%AC%EF%BC%86%EF%BC%86%E7%9F%A9%E9%98%B5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言其实整个系列弄下来是因为尝试做了小米OJ的二月月赛，结果被狠狠压在地上打(哭，看了评论有人给出的题解，有道题因为涉及到矩阵快速幂，所以干脆把快速幂重新再看一遍。 原理一般朴素的幂积算法计算$a^b$时间复杂度是O(n)，而快速幂可以降到O(logn)，实现的原理是将b二进制化，$b=2^a_{1}+2^a_{2}+…+2^a_{k}$ , $a^b=a^｛2^a_{1}｝a^｛2^a_{2}｝…a^｛2^a_{k}｝$。这些a_{i}就是b的二进制为１的位数(末位取０，从低到高依次增1)，下面是具体实现代码 12345678910long long qpow(long long a, long long b) &#123; long long ret = 1; while (b != 0) &#123; if (b &amp; 1) ret *= a; a *= a; //累乘，以便随时对ret做出贡献 b &gt;&gt;= 1; &#125; return ret;&#125; 代码中我们用到了两种位运算 &amp; 和 &gt;&gt;，&amp;运算用于二进制取位操作，例如b&amp;1就是取二进制的末位，b&amp;1==1?b为奇数:b为偶数；&gt;&gt;运算去掉二进制的最后一位，b&gt;&gt;=1相当于b/2（向下取整） 矩阵快速幂矩阵快速幂是建立在快速幂之上的，只不过将a换成了一个矩阵，所以对于矩阵的相乘我们需要单独写一个函数来实现，以下是代码 1234567891011121314151617181920212223int temp[maxn][maxn]; inline void multi(int a[][maxn],int b[][maxn],int n)&#123; memset(temp,0,sizeof(temp)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) temp[i][j]+=a[i][k]*b[k][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=temp[i][j]; &#125; int ret[maxn][maxn]; inline void pow(int a[][maxn],int n)&#123; memser(ret,0,sizeof(ret)); for(int i=1;i&lt;=n;i++) ret[i][i]=1; //初始化为单位矩阵 while(n!=0)&#123; if(n&amp;1) multi(ret,a,n); multi(a,a,n); n&gt;&gt;=1; &#125; &#125; 斐波那契数列的矩阵快速幂求斐波那契数列是一个典型的递归过程，但如果所求的n足够大呢？这时候用矩阵快速幂比递归要好。$$Fib(n) =\begin{cases}0, &amp; \text{ $n$=0 } \1, &amp; \text{ $n$=1} \Fib[n-1]+Fib[n-2], &amp; \text{ $n$&gt;1 }\end{cases}$$$\bigl( \begin{smallmatrix} Fib[n] \ Fib[n-1] \end{smallmatrix} \bigr)$ = $\bigl( \begin{smallmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{smallmatrix} \bigr)$ $\bigl( \begin{smallmatrix} Fib[n-1] \ Fib[n-2] \end{smallmatrix} \bigr)$ = $\bigl( \begin{smallmatrix} 1 &amp; 1 \ 1 &amp; 0 \end{smallmatrix} \bigr)^(n-2)$ $\bigl( \begin{smallmatrix} Fib[2] \ Fib[1] \end{smallmatrix} \bigr)$ { Fib[n] } { 1 1 }{ Fib[n-1] } { 1 1 }^(n-1) { Fib[2]=1 } = ={Fib[n-1]} { 1 0 }{ Fib[n-2] } { 1 0 } { Fib[1]=1 }将模板改为结构体即可，注意结构体要记录矩阵的行数和列数（玄学表达，窝相信你们能懂得]]></content>
      <categories>
        <category>算法</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【图论】求无向连通图的割点（Tarjan算法）]]></title>
    <url>%2F2019%2F01%2F24%2F%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%B1%82%E6%97%A0%E5%90%91%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9%EF%BC%88Tarjan%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言寒假训练开始了，发现自己真是半灌水响叮当，自己关于割点的概念完全不知道，后来找了几篇不错的博客以及翻了翻白书，白书很适合理解概念，博客给的模板代码适合借鉴。 割点的概念在无向连通图中，如果将其中一个点以及这个点所连的所有的边都去掉，图不再连通，那么这个点成为割点（割顶/关节点）。 如何求割点暴力的方法： 依次删除每一个节点v DFS(BFS)判断是否连通 再把节点v加入图中 若用邻接表，需要做V次DFS，时间复杂度为O(V*(V+E))。 DFS搜索树在介绍Tarjan算法之前，首先需要了解几个基本概念 DFS搜索树：用DFS对图进行遍历时，按照遍历的顺序，可以得到一棵DFS搜索树（图呢？？？ 树边：即父子边，可理解为在DFS过程中访问未访问节点时经过的边 回边：也称反向边，即后代指向祖先的边，可理解为在DFS过程中访问已访问节点时经过的边 Tarjan算法本篇的重点即介绍这一算法，该算法是由R.Tarjan发明的（前人真伟大首先选定一个根节点，从该根节点开始遍历整个图（DFS）思考割点的条件，我们发现有两类节点可以成为割点 对于树根u，当且仅当它有两个或更多的子节点时，它才是割点 对于非根节点u，我们有这样一个定理：在无向连通图G的DFS树中，非根节点u是G的割点当且仅当u存在一个子节点v，使得v及其所有后代都没有反向边连回u的祖先（连回u不算）。 如何解释第二种情况呢？思考若其子节点都没有指向u的祖先的回边，说明删除u之后，根节点与u的子树不再连通，自然也就是割点了。很显然，我们需要解决子节点的回边问题。我们维护两个数组dfn[]和low[]，dfn[u]记录节点u在DFS过程中在第几回被第一次遍历到，low[u]记录节点u以及u的后代通过非父子边能追溯到的最早的祖先的dfn值（即dfn值最小），low[u]的计算过程如下 (u,v)为树边，low[u]=min(low[u],low[v]) (u,v)为回边且v不是u的父亲节点，low[u]=min(low[u],dfn[v]) 当(u,v)为树边且low[v]&gt;=dfn[u]时，节点u为割点。该式子的含义是：以节点v为根的子树所能追溯到最早的祖先要么是v要么是u。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int maxn=10000;int dfn[manx],low[maxn],pre[maxn]; //pre[]记录每个节点的祖先，根节点设为-1bool cut[maxn]; //记录该节点是否为割点（因为可能会被重复判断为割点）vector&lt;int&gt; G[maxn];int n,tot; //n为节点数，tot记录割点数量void dfs(int u)&#123; static int cnt=0; //记录dfs的次序 int child=0; dfn[u]=low[u]=++cnt; //默认low[u]=dfn[u] for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i]; if(!dfn[v])&#123; //第一次访问时dfn值为0（dfn初始化为0） child++; pre[v]=u; dfs(v); low[u]=min(low[u],low[v]); //dfs完毕，如果low[v]&lt;low[u]，则更新low[u]（说明后代v所能追溯到最早的祖先在u之前） if(pre[u]==-1&amp;&amp;child&gt;=2&amp;&amp;!cut[u])&#123; //根节点的子节点多于1，满足割点的第一个条件 cut[u]=true; tot++; &#125;else if(pre[u]!=-1&amp;&amp;low[v]&gt;=dfn[u]&amp;&amp;!cut[u])&#123; //割点的第二个条件 cut[u]=true; tot++; &#125; &#125;else if(v!=pre[u])&#123; //(u,v)为回边，且v不是u的父亲 low[u]=min(low[u],dfn[v]); &#125; &#125;&#125; Tarjan算法的时间复杂度为O(V+E)，即一次DFS就可以求出割点 后话我遇到的第一个求割点的题目是UVA315，抄模板的时候cnt设为了int，结果就wa了（超囧）。 最后感谢这两篇博客割点（Tarjan算法）【图论】求无向连通图的割点]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[树状数组不太熟悉，所以下决心写出个教程来，断断续续花了三天（可太断断续续了），听说OI选手最喜欢写树状数组（线段树）了 前言我们将一个数组a[]树状化，每个节点的值C[i]记录了其叶子节点的权值之和，那么树状数组C[]就维护了这个数组a[]的前缀和S[i]=a[1]+a[2]+…+a[i],树状数组利用了二进制，使其可以在O(logn)时间内对这个数组a[]进行修改和求和（与O(n)比起来效率很高） 树状数组可以实现的功能有 将一个数组树状化 区间修改，如改变某一个点a[i]的值 区间查询，如询问a[1]+a[2]+…+a[i]的值 “树状化”数组下面我们来定义C[]数组（也就是把数组树状化）C[i]=a[i-2^k+1]+a[i-2^k+2]+…+a[i]，其中k表示i的二进制中末尾0的个数，例如i=8时，二进制为1000，那么C[8]=a[1]+a[2]+…+a[8]，再例如i=6,二进制为110，则C[6]=a[5]+a[6] 我们怎么求这个神奇的k值呢？（可太神奇了不是吗123int lowbit(int i)&#123; return i&amp;(-i);&#125;//实际上最后return的这个i&amp;(-i)=2^k 区间查询每个c[]的定义解决了，接下来我们来看看树状数组的功能之一————区间查询（这里以求前缀和为例），在此之前你的视角应该从十进制转换为二进制比如我们计算sum[7],如果是O(n)的做法，那么就是sum[7]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]，现在我们试试用树状数组的思想来高效化。7对应的二进制是111，我们把111拆分成100+10+1，仔细发现，lowbit(7)=1,7-1=6，lowbit(6)=2(10),6-2=4，lowbit(4)=4(100),4-4=0,那么sum[7]=C[7]+C[6]+C[4]当我们计算sum[7]时，就大大减少了计算次数，时间复杂度降低，也就实现了高效率求前缀和。而计算其他前n项时也是如此，将n的二进制拆分成2^k之和这样的形式，sum[n]=C[n]+C[n-lowbit(n)]+C[n-lowbit(n)-lowbit(n-lowbit(n))]+….,其中这里的lowbit(n)即是前面的2^k下面是求前缀和的代码 12345678int getsum(int pos) &#123; int ans = 0; while (pos != 0) &#123; ans += c[pos]; pos -= lowbit(pos); &#125; return ans;&#125; 同理我们想求得区间和，比如a[i]+a[i+1]+…+a[j]=getsum(j)-getsum(i-1) 区间修改接下来我们来实现区间修改功能（这里以单点更新为例），每次修改时我们更新某个a[i]的值，那么我们便要从这个a[i]节点开始向上不断更新C[]的值（即更新父节点），以保证C[]维护的前缀和保持更新根据前面关于C[]的公式，我们可以发现每个节点i与它的父节点相差lowbit(i)，即C[i]更新了，下一个就要更新C[i+lowbit(i)]（这一步我解释得很生硬，因为我不能很好地解释清楚，只好放结论了）以下是代码部分 123456void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]=x; pos=lowbit(pos); &#125;&#125; 单点更新和区间查询模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int c[100005];int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); update(i,x); &#125; int opt,a,b; for(int i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;opt,&amp;a,&amp;b); if(opt==1) update(a,b); else printf("%d\n",getsum(b)-getsum(a-1)); &#125; &#125; return 0;&#125; 区间修改和单点查询树状数组的单点更新和区间查询功能我们已经实现，接下来我们来实现其他几个功能区间修改和单点查询我们新定义一个差分数组c1[i]=a[i]-a[i-1]，那么a[i]=c1[1]+c1[2]+…+c1[i]，如果我们想把a[i]~a[j]都更新（比如+x），那么只需令c1[i]+=x,c1[j+1]-=x以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;int c[100005];int n,m;int lowbit(int i)&#123; return i&amp;(-i);&#125;int getsum(int pos)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int x)&#123; while(pos&lt;=n)&#123; c[pos]+=x; pos+=lowbit(pos); &#125;&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,y-x); x=y; &#125; int opt,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); update(x,k); update(y+1,-k); &#125; else&#123; scanf("%d",&amp;x); printf("%d\n",getsum(x)); &#125; &#125; &#125; return 0;&#125; 区间查询和区间更新观察下列式子a[1]+a[2]+…+a[n]=(c1[1])+(c1[1]+c1[2])+(c1[1]+c1[2]+c1[3])+…+(c1[1]+c1[2]+…+c1[n])=nc1[1]+(n-1)c1[2]+…+c1[n]=n(c1[1]+c1[2]+…+c1[n])-(0c1[1]+1c1[2]+…+(n-1)c1[n])=(n+1)(c1[1]+c1[2]+…+c1[n])-(1c1[1]+2c1[2]+…+nc1[n])那么我们便维护一个数组c2[]，其中c2[i]=i*c[i]，每当我们修改c[]时，同步修改c2[]，总体复杂度还是O(logN)以下是模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int c[100005][2];int n,m;int lowbit(int i)&#123; return i&amp;-i;&#125;int getsum(int pos,int f)&#123; int ans=0; while(pos!=0)&#123; ans+=c[pos][f]; pos-=lowbit(pos); &#125; return ans;&#125;void update(int pos,int f,int x)&#123; while(pos&lt;=n)&#123; c[pos][f]+=x; pos+=lowbit(pos); &#125;&#125;int ask(int pos)&#123; return (pos+1)*getsum(pos,0)-getsum(pos,1);&#125;int main(void)&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int x=0,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;y); update(i,0,y-x); update(i,1,i*(y-x)); x=y; &#125; int opt,a,b,k; for(int i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;k); update(a,0,k); update(b+1,0,-k); update(a,1,a*k); update(b+1,1,-(b+1)*k); &#125; else&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",ask(b)-ask(a-1)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git操作总结(一)]]></title>
    <url>%2F2018%2F10%2F10%2FGit%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经久没有使用git（捂脸跑开），今天开会被czq小朋友教做人，所以欸真的需要再回顾一下git操作啊(:зゝ∠)。于是上git官网从头到尾仔仔细细看了一波（不能再废下去了啊喂（摇醒）。也相当于给自己做一个git笔记，以后有忘记的命令操作就来这里看啦。 前言Git是一种分布式版本控制系统，这与常被混淆的Github(只支持Git做版本控制的项目托管平台)是两种不同的概念。在Git中的绝大多数操作都只需要访问本地文件和资源，Git和其他版本控制系统的主要差别在于对待数据的方法，其他大部分系统以文件变更列表的方式存储信息，而Git更像是把数据看作是一组快照，每次提交修改和更新时对这个文件制作一个快照并保存这个快照的索引(其中以文件内容的哈希值来作为索引)。 由于git的使用非常灵活，在实践过程中便衍生出很多种不同的工作流程和协作方式。Git有多种使用方式，强烈建议使用命令行模式。Git安装跳过，请自行使用强大的搜索引擎。 Git基础Git工作流程首先聊聊Git的工作流程，Git有三种状态，你的文件可能处于其中之一 已提交(committed) → 数据已经保存在本地数据库中 已修改(modified) → 修改了文件但还没保存到数据库中 已暂存(staged) → 对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中 由此再引入三个工作区域的概念 Git仓库 → 保存项目的数据 工作目录 → 对项目的某个版本提取出来的内容 暂存区域 → 保存下次将提交的文件列表信息 基本的Git工作流程如下 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照存储到Git仓库 是不是感觉看不懂很头大？那你继续大着看下去吧) Git仓库(Repository)从项目的开始到结尾，我们会接触两种仓库，一种是源仓库(origin), 一种是开发者仓库。源仓库是由项目发起者构建，它汇总了所有参与开发的各个开发者的代码，存放趋于稳定和可发布的代码。当源仓库建立后，开发者应把源仓库”复制”一份，自己的日常开发就在这个复制的仓库进行，即”fork”一下。每个开发者fork的仓库是独立，互不干扰的，而当开发工作完成以后，开发者可以向源仓库发送pull request，请求管理员把自己的代码合并到源仓库中，这样就实现了分布式开发工作(可太分布了不是吗)。 下面讲讲获取Git仓库的两种方法 在现有的目录中初始化比如说我有一个项目目录test，那么我只需要进入该项目目录并输入： 12git init#初始化仓库，该命令将创建一个.git子目录，用来存放初始化的Git仓库中所有的必须文件 注意现在项目的文件还没有被跟踪(被标记)，我们需要 12git add *#跟踪目录下的所有文件，即Git工作流程的第二步 克隆现有的仓库开发者在fork源仓库后就会有一个属于自己的开发者仓库，我们想要把它clone到本地 12git clone git@github.com:yourname/reponamegit#这会在当前目录下创建一个名为reponame的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉取所有数据放入.git文件夹，然后读取文件的拷贝 仓库更新我们无非就是对仓库里的文件进行操作，而文件只有两种状态，已追踪和未追踪。Git的操作逻辑是，编辑文件后，它就是一个已修改文件，我们需要把这个文件放入暂存区，然后提交所有暂存区的文件，以此反复。12345git add &lt;filename&gt;#将文件放入暂存区，状态为已追踪git commit -m 'xxxx'#提交暂存区所有的文件，'xxxx'是提交的说明 注意，每次修改后文件都需要放入暂存区，这样才能提交更新后的信息(你也可以理解为git add的意思是添加内容到下一次提交中，如果文件没有被追踪，那么下一次要提交的内容便不包含它) 那么很自然会想到，我们怎么查看文件的状态呢？输入：1git status 可是git status的输出有时候太不友好了，我们迫切地想知道到底修改了那些地方，输入12git diff#比较工作目录中当前文件和暂存区域快照之间的差异，即修改之后没有暂存的文件变化内容 有时候聪明的你也会粗心，忘了把修改后的文件git add了，那么有没有什么命令能解决呢？12git commit -a#把所有已经被跟踪的文件打包暂存然后提交 啊有时候我们想删掉一个文件，但这个文件被追踪过，如果我们只是单纯地删除这个文件，你会发现在未暂存清单里会看见这个文件，这时候输入12git rm &lt;filename&gt;#将文件从暂存区域清除，再从工作目录中删除]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
